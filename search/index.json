[{"content":"生成随机数\r1 2 3 4 5 6 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; srand((unsigned int) time(NULL)); //传入时间戳 注意，该行语句只需要调用一次！ int rand_sum = rand(); //生成随机数 rand_sum = rand_sum % 100 + 1; //生成1-100范围的随机数 二分查找\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main() { int arr[10] = { 1,8,10,21,57,89,98,107,428,890 }; int sum = 0; printf(\u0026#34;请输入要查找的数字 \u0026gt;\u0026gt;\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;sum); int size = sizeof(arr) / sizeof(arr[0]); int left = 0; int right = size - 1; while (left \u0026lt;= right) { int middle = (left + right) / 2; if (arr[middle] \u0026lt; sum) { left = middle + 1; } else if (arr[middle] \u0026gt; sum) { right = middle - 1; } else { printf(\u0026#34;%d数字在数组中的下标是%d\\n\u0026#34;, sum, middle); break; } } if (left \u0026gt; right) { printf(\u0026#34;%d在数据中不存在\\n\u0026#34;, sum); } return 0; } 算法逻辑:\n首先找到要被查找数组中最中间的元素与被查找元素进行比较 由于例子中数组内容为由小到大顺序排列。因此与最中间的数进行比较。如果大就往右侧查找，这样直接筛选掉左侧的所有元素 然后循环查找，在右侧中找中间值，继续查找。循环查找 直到查找到 / 右侧下标大于左侧下标(未找到) 查找结束 冒泡排序\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Bubble_Sort(int arr[], int sz) { for(int i = 0; i \u0026lt; sz - 1; i++) { for(int j = 0; j \u0026lt; sz - 1 -i; j++) { if(arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } } 假设总共有10个数，因此共需要比较 10 - 1 次 即 i \u0026lt; sz - 1 然后在这一趟中，两两相比，如果不符合条件就交换 辗转相除法\r1 2 3 4 5 6 7 8 9 10 11 int gcd(int a, int b) { while(b) { int temp = a % b; a = b; b = temp; } retrun a; } 打印闰年\r闰年的要求为:\n可以被4整除但不能被10整除 可以被400整除 因此表达式可以写为:\n(year % 4 == 0) \u0026amp;\u0026amp; (year % 100 != 0) (year % 400 == 0) 写成判断表达式为:\n1 if((!(year % 4) \u0026amp;\u0026amp; !(year % 100)) || !(year % 400)) 因为在C中，0为false 非0为true\n! 为取反\n输出 1000 - 2000 之间的闰年\r1 2 3 4 5 6 7 8 9 10 11 12 int main() { for(int year = 1000; year \u0026lt;= 2000; year++) { if((!(year % 4) \u0026amp;\u0026amp; !(year % 100)) || !(year % 400)) { cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 输出素数\r素数，又称质数。是指在大于 1 的自然数中，除了 1 和它本身以外不能被其他自然数整除的数\n最简单的想法可以这样:\n遍历 2 - sum 本身之间的所有数，进行遍历。同时设定一个变量 flag 且假定这个数是素数。一旦能被其他数整除就更改flag变量的值\n1 2 3 4 5 6 7 8 9 int flag = 1; for(int i = 2; i \u0026lt; sum; i++) { if(!(sum % i)) { flag = 0; break; } } 计算如下级数\r$$\r\\sum_{n=1}^{100} (-1)^{n-1} \\frac{1}{n} = \\frac{1}{1} - \\frac{1}{2} + \\frac{1}{3} - \\frac{1}{4} + ... + \\frac{1}{99} - \\frac{1}{100} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { double sum; for(int n = 1; n \u0026lt;= 100; n++) { if(n % 2 == 1) { sum += 1.0 / n; } else { sum -= 1.0 / n; } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; return 0; } 求最大/小值\r首先需要一个数来和需要求最大值的数组进行比较。这个数必须是一个合理的值。不能比要比较的所有数都大/小。否则无法比较\n也不能是数组内的元素，可能会出现问题\n1 2 3 4 5 6 7 8 9 //假设使用0作为比较的数字 int max = 0; for(int i = 0; i \u0026lt; /* 数组的最大元素下标 */; i++) { if(max \u0026lt; arr[i]) { max = arr[i]; //如果发现目前的最大值没有数组内当前下标的值大，就替换 } } 输出 99 乘法表\r1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { for(int i = 1; i \u0026lt;= 9; i++) { for(int j = 1; j \u0026lt;= i; j++) { printf(\u0026#34;%d * %d = %-2d \u0026#34;, i, j, i * j); } printf(\u0026#34;\\n\u0026#34;); } return 0; } %-2d为缩进向右两个字符\n大小写字母转换\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { char ch; scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); if(ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { ch += 32; } else if(ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) { ch -= 32; } cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } 必须使用 else if ! 否则一旦一个字符从大写转换为小写，它将立即被第二个 if 语句转换为大写\n输入 3 个整数，以从大到小的顺序输出\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { int a, b, c, t; printf((\u0026#34;请输入三个整数:n\u0026#34;): scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if (a \u0026gt; b) { t = a; a = b; b = t; } if (a \u0026gt; c) { t = a; a = c; c=t; } if(b \u0026gt; c) { t = b; b = c; c = t; } printf(\u0026#34;%d %d %d\\n\u0026#34;,a,b,c); return 0; } 计算累加阶乘的和\r$$\r\\sum_{n = 1}^{10} 1! + 2! + 3! + ... + 10!\r$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { int sum = 0; int ret = 1; for(int i = 1; i \u0026lt;= 10; i++) { ret *= i; sum += ret; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; return 0; } 使用递归求阶乘\r1 2 3 4 5 6 7 8 9 10 11 int fun(int x) { if(!x) { retrun 1; } else { retrun x * fun(x - 1); } } 该方法仅适用于不考虑栈溢出的情况！\n使用递归将字符串逆序\r1 2 3 4 5 6 7 8 9 10 11 12 13 void Reverse(char* str) { char tmp = *str; //取出第一个字符 int len = strlen(str); *str = *(str + len - 1); //和最后一个字符交换 *(str + len - 1) = \u0026#39;\\0\u0026#39;; //刚刚替换的最后一个字符变为\\0 if(strlen(str + 1) \u0026gt;= 2) //判断未交换字符串长度 { Reverse(str + 1); //传入下一个需要交换的字符 } *(str + len - 1) = tmp; //将最后一个字符换成取出的第一个字符 } 使用递归实现n的k次方\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 double Pow(int n, int k) { if(!k) { return 1; } else if(k \u0026gt; 0) { return n * Pow(n, k - 1); } else { return 1.0 / (Pow(n, -k)); } } 将一个数分解质因数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { int n = 90; printf(\u0026#34;%d = \u0026#34;, n); for(int i = 2; i \u0026lt;= n; i++) { while(n != i) { if(!(n % i)) { printf(\u0026#34;%d * \u0026#34;, i); n /= i; } else { break; } } } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 求最大公约数和最小公倍数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { int a = 12; int b = 16; int ret = a * b; while(a != b) { if(a \u0026gt; b) { a -= b; } else { b -= a; } } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ret / a \u0026lt;\u0026lt; endl; return 0; } 求最小公倍数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int a = 0; int b = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); for(int i = 1; ; i++) { if(!(a * i \u0026amp; b)) { printf(\u0026#34;%d\\n\u0026#34;, a * i); break; } } return 0; } 不创建第三变量进行数值交换\r1 2 3 4 5 6 7 8 9 10 //方案一 容易溢出 int main() { int a = 3; int b = 5; a = a + b; //a = 8 b = 5 b = a - b; //b = 8 - 5 = 3 a = a - b; //a = 8 - 3 = 5 } 1 2 3 4 5 6 7 8 9 10 //方案二 使用异或操作符 int main() { int a = 3; //011 int b = 5; //101 a = a ^ b; //a = 110 b = 101 b = a ^ b; //a = 110 b = 011 a = a ^ b; //a = 101 b = 011 } 求一个整数在内存中1的个数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 int NumberOf1(size_t n) { int count = 0; while(n) { if(n % 2) { count; } n /= 2; } return count; } //仅适用于正数的写法 1 2 3 4 5 6 7 8 9 10 11 12 int NumberOf1(int n) { int count = 0; for(int i = 0; i \u0026lt; 32; i++) { if((n \u0026gt;\u0026gt; i) \u0026amp; 1) { count++; } } return count; } 1 2 3 4 5 6 7 8 9 10 11 //方法2 int NumberOf1(int n) { int count = 0; while(n) { n = n \u0026amp; (n - 1); count++; } return count; } 求水仙花数(自幂数)\r一个n位数，其每一位的数字的n次方之和正好等于其本身\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int Is_Math(int sum) { int count = 1; int tmp = sum; while(tmp / 10) { tmp /= 10; n++; } tmp = sum; int math = 0; while(tmp) { math += pow(tmp % 10, count); tmp /= 10; } if(math == sum) { return 1; } return 0; } 一个数 /10%10 即可拿到这个数的末位。只要每次拿到末位后/=10再进行循环即可拿到这个数的每一位\n但是这样会更改原本数的内容！所以如果还需要使用该数请做好备份！\n左旋k个字符\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Left_Move(char* str, int k) { int len = strlen(str); for(int i = 0; i \u0026lt; k; i++) { char tmp = *str; for(int j = 0; j \u0026lt; len - 1; j++) { *(str + j) = *(str + j + 1); } *(str + n - 1) = tmp; } } 打分的平均值\r有n位考官，输入若干个成绩，去掉一个最高分和最低分求平均分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { int n = 10; double sum = 0.0; double score = 0.0; double max = 0.0; double min = 100.0; for(int i = 0; i \u0026lt; n; i++) { scnaf(\u0026#34;%d\u0026#34;, \u0026amp;score); sum += score; if(score \u0026gt; max) { max = score; } if(score \u0026lt; min) { min = score; } } pinrtf(\u0026#34;%.2f\\n\u0026#34;, (sum - max - min) / n); return 0; } 在有序数组中插入一个数字\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define n 10 //有序数组的长度 需留出插入的空间 void Insert(int* arr, int sum) { int i = n - 1; for(i; i \u0026gt;= 0; i--) { if(arr + i \u0026gt; sum) { arr + i + 1 = arr + i; } else { arr + i + 1 = sum; break; } } if(i \u0026lt; 0) { arr + 0 = sum; } } ","date":"2025-08-28T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/111793467_p0.webp","permalink":"https://blog.candquarzy.top/p/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/","title":"C语言相关算法"},{"content":"准备知识\rJetpackCompose 相比传统 XML+Java 的优势\r不需要多个 XML 和 Activity\n可组合函数负责更新和构建页面\n不需要通过 ID 来查找视图，而是通过视图来绑定\n与 Java+XML 的传统方式相兼容\n使用 JetpackCompe 构建页面\r在 Andorid Studio 中新建项目，选择 Empty Compose Activity 后点击 Next\n需要 API 21+\n只能使用 Kotlin 语言\nAndoridManifest.xml 文件\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:dataExtractionRules=\u0026#34;@xml/data_extraction_rules\u0026#34; android:fullBackupContent=\u0026#34;@xml/backup_rules\u0026#34; android:icon=\u0026#34;@mipmap/my_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundIcon=\u0026#34;@mipmap/my_launcher_round\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/Theme.Profile\u0026#34; tools:targetApi=\u0026#34;31\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:theme=\u0026#34;@style/Theme.Profile\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; application 内属性\nandroid:icon App 的主图标\nandroid:label 应用名称\nandroid:roundIcon 应用背景图标\nandroid:theme 应用的主题\nactivity 内属性:\nandroid:name 应用启动后的主页面\nandroid:label 应用名称\nandroid:theme 应用的主题\n资源引用\r1 @[xxx]/[xxxx] [xxx] 为引用资源的路径\n[xxxx] 为引用资源的名称，不包括文件后缀\n如在 string.xml 内定义的应用名称:\n1 2 3 \u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;Candy\\\u0026#39;s Profile\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; 在其他位置的引用可以使用:\n1 @string/app_name 依赖项\r在 build.gradle(:app) (注：作用域是 app) 下的 dependencies 组为依赖项，可以在这里添加你需要使用的库\n案例 1 个人页面\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 package com.candy.ui_test import android.R.attr.text import android.R.attr.top import androidx.compose.foundation.Image import androidx.compose.foundation.border import androidx.compose.foundation.layout.Arrangement import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.fillMaxHeight import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.padding import androidx.compose.foundation.layout.size import androidx.compose.foundation.layout.width import androidx.compose.foundation.rememberScrollState import androidx.compose.foundation.shape.RoundedCornerShape import androidx.compose.foundation.verticalScroll import androidx.compose.material3.Button import androidx.compose.material3.Card import androidx.compose.material3.CardDefaults import androidx.compose.material3.ElevatedButton import androidx.compose.material3.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.draw.clip import androidx.compose.ui.graphics.Color import androidx.compose.ui.layout.ContentScale import androidx.compose.ui.res.painterResource import androidx.compose.ui.text.font.FontWeight import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.dp import androidx.compose.ui.unit.sp @Composable fun ProfilePage() { Card( //卡片 elevation = CardDefaults.cardElevation(defaultElevation = 8.dp), // 正确的写法 (适用于 Material 3) // elevation = 8.dp, // 在 Material 2 中这是可以的 modifier = Modifier.height(600.dp) //设置卡片高度 // .fillMaxSize() .padding(top = 150.dp, bottom = 50.dp, start = 16.dp, end = 16.dp) ) { Column( //一种列表布局 modifier = Modifier.fillMaxHeight()//先添加该属性，填满整个高度 .verticalScroll(rememberScrollState()), //列表垂直滚动 参数为记住列表滚动状态 horizontalAlignment = Alignment.CenterHorizontally, //列表水平居中 verticalArrangement = Arrangement.Center, //列表垂直居中 填满后生效 ) { Image( painter = painterResource(id = R.drawable.photo), //图片的画家，即为图片路径 contentDescription = \u0026#34;Candy\u0026#34;, //图片的描述 modifier = Modifier.size(125.dp) //图片的尺寸 // .clip(CircleShape) //图片的纯圆修饰符 .clip(RoundedCornerShape(15)) //图片的圆角形状 单位int 50为纯圆 .border( width = 1.dp, //图片的边框宽度 color = Color.White, //图片的边框颜色 shape = RoundedCornerShape(15) //图片的边框形状 ), //图片的边框 contentScale = ContentScale.Crop //图片的裁剪方式 ) Text( text = \u0026#34;Candy\u0026#34;, fontWeight = FontWeight.Bold, //字体加粗 fontSize = 30.sp, //字体大小 ) Text( text = \u0026#34;@Candquarzy\\uD83C\\uDFF3\\uFE0F\\u200D⚧\\uFE0F\u0026#34;, fontSize = 12.sp, //设置字体大小 ) Row( horizontalArrangement = Arrangement.SpaceEvenly, //列表水平均匀排列 modifier = Modifier.fillMaxWidth() //填满整个宽度 .padding(16.dp) //添加外边距 ) { ProfileData(\u0026#34;5.28k\u0026#34;, \u0026#34;粉丝\u0026#34;) //调用函数 ProfileData(\u0026#34;114\u0026#34;, \u0026#34;关注\u0026#34;) //调用函数 ProfileData(\u0026#34;87\u0026#34;, \u0026#34;动态\u0026#34;) //调用函数 } Row( horizontalArrangement = Arrangement.SpaceEvenly, //列表水平均匀排列 modifier = Modifier.fillMaxWidth() //填满整个宽度 // .padding(16.dp) //添加外边距 ) { ElevatedButton( onClick = { /* TODO */ }) { Text( text = \u0026#34;关注\u0026#34;, ) } ElevatedButton( onClick = { /* TODO */ }) { Text(\u0026#34;私信\u0026#34;) } } } } } @Composable fun ProfileData(count: String, text: String) //函数 用于存储数据列表 { Column( horizontalAlignment = Alignment.CenterHorizontally, //列表水平居中 ) { Text( text = count, fontWeight = FontWeight.SemiBold, //字体加粗 ) Text( text = text, ) } } @Preview(showBackground = true) //预览注解 + 显示背景 @Composable fun ProfilePagePreview() { ProfilePage() } 布局\rColumn 垂直布局\r1 import androidx.compose.foundation.layout.Column 一种纵向的列表布局\n参数\nverticalArrangement 垂直对齐方式 属性值为 Arrangement.[direction]\nhorizontalAlignment 水平对齐方式 属性值为 Alignment.[direction]\ncontent 暂不确定\nmodifier 参数\n.fillMaxSize/Widht/Height() 列表填满父容器 (宽度 / 高度)\n.padding([int.dp]) 外边距\n.margin([int.dp]) 内边距\n.requiredHeight(Weight) 强制设置高度 / 宽度 (不受父高度影响强制设 置)\nRow 水平布局\r1 import androidx.compose.foundation.layout.Row 一种纵向的列表布局\n参数\nverticalArrangement 垂直对齐方式 属性值为 Arrangement.[direction]\nhorizontalAlignment 水平对齐方式 属性值为 Alignment.[direction]\ncontent 暂不确定\nmodifier 参数\n.fillMaxSize/Widht/Height() 列表填满父容器 (宽度 / 高度)\n.padding([int.dp]) 外边距\n.margin([int.dp]) 内边距\n.requiredHeight(Weight) 强制设置高度 / 宽度 (不受父高度影响强制设 置)\nCard 卡片布局\r1 import androidx.compose.material3.Card 一种卡片形式的布局\n参数\nshape 卡片形状\ncolors 卡片颜色\nelevation 卡片悬浮高度 (MD3: CardDefaults.cardElevation(defaultElevation = [int].dp) ; MD2: [int].dp ) int 值为阴影模糊程度\nborder 卡片边框线\ncontent 暂不确定\nmodifier 参数\n.fillMaxSize/Widht/Height() 列表填满父容器 (宽度 / 高度)\n.padding([int.dp/sp]) 外边距 (可以分开设置 top bottom start end)\n.height([int.dp]) 卡片高度\n.weight([int.dp]) 卡片宽度\n.requiredHeight(Weight) 强制设置高度 / 宽度 (不受父高度影响强制设置)\n约束布局\r1 import androidx.constraintlayout.compose.ConstraintLayout 一种使用 ID 来绑定组件的布局，可以更方便的定义组件所在页面中的位置\n而在这种布局下， horizontalAlignment 和 verticalArrangement 不再可用\n要使用约束布局，需要在 build.gradle 中添加依赖项:\n1 implementation (\u0026#34;androidx.constraintlayout:constraintlayout-compose:1.1.1\u0026#34;) 截至写这篇文章的时候，最新的版本为 1.1.1\nConstraintlayout | Jetpack | Android Developers\n要使用约束布局，需要按以下方式:\n使用 createRefs() 或 createRefFor() 为 ConstraintLayout 中的每个可组合项创建引用\n约束条件使用 Modifier.constrainAs() 修饰符提供的，该修饰符将引用作为参数，然后指定其约束条件\n约束条件使用 linkTo() 方法指定\nparent 是一个屏幕位置，可用于指定对 ConstraintLayout 可组合项本身的约束条件\nmodifier 参数\n由 .constrainAs([String id]) 控制\ntop.linkTo() 顶部链接到\nbuttom.linkTo() 底部链接到\nstart.linkTo() 起始处链接到\nend.linkTo() 结尾处链接到\nwidth 属性值 (如 Dimension.wrapContent*)\n该项目中所有参数均为所设定的控件 ID 其中，parent 为父级，可以理解为屏幕\n使用 Dimension.wrapContent 需要导入\n1 import androidx.constraintlayout.compose.Dimension 约束布局的解耦合\r优势：有助于实现横屏和竖屏的切换\n首先需要导入一个盒子约束容器\n在其内部定义一个变量，通过判断来判断用户当前为横屏还是竖屏，接着设置约束方法函数\n而在该约束容器内部的约束布局内的元素需要给 Modifier 注册.layoutId (“String”)，并在约束方法中引用\n比如导入\n1 import androidx.compose.foundation.layout.BoxWithConstraints BoxWithConstraints 约束盒子容器 \u0026lt;待定\n约束方法\r创建一个保护的成员函数\n\u0026lt;待定\nScaffold \u0026ldquo;脚手架\u0026rdquo; 布局\r1 import androidx.compose.material3.Scaffold Scaffold 是一种类似于框架一样的结构。它将界面的不同部分整合在一起，使其具有一致的外观和风格\ntopBar 应用的屏幕顶部应用栏\nbottom 应用的屏幕底部应用栏\nfloatingActionButton 悬浮在屏幕右下角的按钮\nScaffold 会自动计算举例宽度，所以在该可组合函数内部要使用 innerPadding-\u0026gt; 来传入边距\n案例 (来自谷歌官方):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Composable fun ScaffoldExample() { var presses by remember { mutableIntStateOf(0) } Scaffold( topBar = { TopAppBar( colors = topAppBarColors( containerColor = MaterialTheme.colorScheme.primaryContainer, titleContentColor = MaterialTheme.colorScheme.primary, ), title = { Text(\u0026#34;Top app bar\u0026#34;) } ) }, bottomBar = { BottomAppBar( containerColor = MaterialTheme.colorScheme.primaryContainer, contentColor = MaterialTheme.colorScheme.primary, ) { Text( modifier = Modifier .fillMaxWidth(), textAlign = TextAlign.Center, text = \u0026#34;Bottom app bar\u0026#34;, ) } }, floatingActionButton = { FloatingActionButton(onClick = { presses++ }) { Icon(Icons.Default.Add, contentDescription = \u0026#34;Add\u0026#34;) } } ) { innerPadding -\u0026gt; Column( modifier = Modifier .padding(innerPadding), verticalArrangement = Arrangement.spacedBy(16.dp), ) { Text( modifier = Modifier.padding(8.dp), text = \u0026#34;\u0026#34;\u0026#34; This is an example of a scaffold. It uses the Scaffold composable\u0026#39;s parameters to create a screen with a simple top app bar, bottom app bar, and floating action button. It also contains some basic inner content, such as this text. You have pressed the floating action button $presses times. \u0026#34;\u0026#34;\u0026#34;.trimIndent(), ) } } } 官方文档: Scaffold - Jetpack Compose | Android Developers\nLazyColumn / LazyRow \u0026ldquo;懒\u0026rdquo; 列 / 行布局\r1 2 import androidx.compose.foundation.lazy.LazyColumn import androidx.compose.foundation.lazy.LazyRow 这是一个可以扩展长度的容器，在该容器内的元素必须是动态长度\n需要使用 item lambda 等遍历容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 val itemsList = (0..5).toList() val itemsIndexedList = listOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) @Composable LazyColum( ) { items(itemsList){ Text( text = \u0026#34;Item is ${it}\u0026#34;, ) } } Box 盒子布局\r1 import androidx.compose.foundation.layout.Box 可以层叠元素的盒子，类似于 HTML 中的 div 标签\n控件\rText 文本组件\r1 import androidx.compose.material3.Text 一种显示文本的文本组件\n参数\ntext 文本内容，类型为 String\ncolor 文本颜色\nfontSize([int].dp) 文字大小\nfontStyle 文本风格？\nfontWeight 字体粗细，由 FontWeight 类控制\nfontFamily 字体家族，由 FontFamily 类控制\ntextAlign 文本对齐方式？\nImage 图像组件\r1 import androidx.compose.foundation.Image 一种显示图像的组件\npainter 画家 (图像路径)\ncontentDescription 图像的描述 (针对视障人士)\ncontentScale 图片的裁剪方式 (如填充横向 填充纵向等等)\nalignment 对齐方式 (默认居中)\nalpha 不透明度 (单位 Float)\n官方文档: 加载图片 | Jetpack Compose | Android Developers\nmodifier 参数\n.size 图片尺寸 / 大小 (单位 dp)\n.clip 图片形状 [如 CircleShape 为纯圆，可以使用RoundedCornerShape([int].dp) 自定义圆角]\n.border 图片边框\n官方文档: 自定义图片 | Jetpack Compose | Android Developers\nTextField 文本输入框\r1 import androidx.compose.material3.TextField 一种用于让用户输入的文本框有多种样式可选\nTextField 基础的默认的样式，样式为填充\nOutlinedTextField 轮廓样式版本，无填充\nSecureTextField 安全输入，用于输入密码等\nvalue 输入框内的值\nonValueChange 当输入框内容变更后执行\nlabel 输入框提示值\n以下是一个案例，当用户输入内容更新后将用户输入的内容输出在 UI 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 var name_state by remember { mutableStateOf(\u0026#34;\u0026#34;) //使用remember和mutableStateOf创建一个可变状态变量 } var name: String by rememberSaveable { //使用rememberSaveable可以在页面旋转时保存数据 mutableStateOf(\u0026#34;\u0026#34;) //使用remember和mutableStateOf创建一个可变状态变量 //只有这样在变化时才会进行页面重组 } Column( horizontalAlignment = Alignment.CenterHorizontally, //水平对齐居中 verticalArrangement = Arrangement.Center, //垂直对齐居中 modifier = Modifier.fillMaxSize(), //填充满屏幕 ) { Text(\u0026#34;Hello $name\u0026#34;); //文本组件 将name的值复制给文本 //当name的值改变时，文本会自动更新(刷新界面) Spacer(modifier = Modifier.height(20.dp)) //间隔组件，设置高度为20dp TextField( //文本输入框 value = name_state, //原本文本框是无状态的， // 然后使用remember和mutableStateOf创建了一个 // 可变状态变量name_state 并分配给它 onValueChange = { //当输入框的值改变时调用 name_state = it //更新状态 }, label = { Text(\u0026#34;请输入:\u0026#34;) } ) Button( onClick = { name = name_state //点击按钮时将输入框的值赋给name } ) { Text(text = \u0026#34;显示\u0026#34;) } } 官方文档: 配置文本字段 Jetpack Compose | Android Developers\nSpacer 空行分隔符\r1 import androidx.compose.foundation.layout.Spacer modifier 参数\n.size 大小\n.weight 空行的宽度\n.height 空行的高度\nIcon 图标组件\r1 2 import androidx.compose.material3.Icon import androidx.compose.material.icons.Icons //导入谷歌的图标类 imageVector 图标名 谷歌官方提供的图标都在 Icons. 类下\ncontentDescription 无障碍提示\ntint 应用于 imageVector, 如果提供了 Color.[name] , 则不应用色调\nNavigationBar 底部导航栏\r1 import androidx.compose.material3.NavigationBar containerColor 底部导航栏的背景色\ncontentColor 底部导航栏的文字 / 图标的颜色\nNavigationBarItem 导航栏图标按钮\r1 import androidx.compose.material3.NavigationBarItem selected 是否选中\nonClick 点击事件，常用于导航跳转\nicon 按钮图标\nlabel 文本内容\n这俩常用在一起，用于给 Scaffold 添加 bottomBar\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 NavigationBar( ) { items.forEach { item -\u0026gt; NavigationBarItem( selected = false, onClick = { }, icon = { Icon( ) }, label = { Text( ) } ) } } 通常来说会将图标和文字放在别处\n创建一个包 model 新建一个 kotlin 类 在类中创建对象，并在导航栏中引用 IconButton 按钮图标组件\r1 import androidx.compose.material3.IconButton onClick 点击事件\nenabled 启用按钮 (默认为 true)\ncolors 按钮的颜色\n可以在内部设置 Icon 图标和文字\n1 2 3 4 5 6 7 8 9 10 11 12 13 IconButton( onClick = { //点击事件 } ) { Icon( //图标设置 ) Text( //显示文本设置 ) } Dialog 对话框组件\r1 import androidx.compose.ui.window.Dialog onDismissrequest 用户关闭对话框（例如点按对话框以外的任意位置）时调用\nproperties 一个 DialogProperties 实例，可提供一些额外的自定义范围\n1 import androidx.compose.ui.window.DialogProperties //使用DialogProperties需要导入 AlertDialog 提醒对话框组件\r1 import androidx.compose.material3.AlertDialog 这是一个便捷的 API，用于创建一个简易的对话框，如取消确认等\ntitle 对话框标题\ntext 对话框内说明文本\nicon 对话框顶部显示的图标\nonDismissrequest 用户关闭对话框（例如点按对话框以外的任意位置）时调用\ndismissButton 用于关闭的可组合函数\nconfirmButton 用于确认的可组合函数\n以下是谷歌官方案例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Composable fun AlertDialogExample( onDismissRequest: () -\u0026gt; Unit, onConfirmation: () -\u0026gt; Unit, dialogTitle: String, dialogText: String, icon: ImageVector, ) { AlertDialog( icon = { Icon(icon, contentDescription = \u0026#34;Example Icon\u0026#34;) }, title = { Text(text = dialogTitle) }, text = { Text(text = dialogText) }, onDismissRequest = { onDismissRequest() }, confirmButton = { TextButton( onClick = { onConfirmation() } ) { Text(\u0026#34;Confirm\u0026#34;) } }, dismissButton = { TextButton( onClick = { onDismissRequest() } ) { Text(\u0026#34;Dismiss\u0026#34;) } } ) } 官方文档: 对话框 | Jetpack Compose | Android Developers\nxxxDivider 分割线组件\rHorizontalDivider 水平分割线\nVerticalDivider 垂直分割线\n组件参数:\nthickness 使用此参数指定分隔线的粗细\ncolor 使用此参数指定分隔线的颜色\n官方文档: 分隔线 | Jetpack Compose | Android Developers\nChip 条状标签\r1 2 import androidx.compose.material3.Chip import androidx.compose.material3.ChipDefaults 有多种样式可选\nonClick 设定点击状态\nlabel 设定显示文字 需要 Composable 函数\nselected 是否选中\nleadingIcon 定义菜单项中前方显示的图标 需要 Compose 函数\ntrailingIcon 定义菜单项中后方显示的图标 需要 Compose 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 var select by remember { mutableStateOf(false) } FilterChip( onClick = { select = !select }, label = { Text( text = \u0026#34;about\u0026#34; ) }, selected = select, leadingIcon = { if (select) { { Icon( /* ICON */ ) } } else { null }, } ) 官方文档: 条状标签 | Jetpack Compose | Android Developers\nDropdownMenu 下拉菜单\rexpanded 菜单是否可见\nonDismissRequest 处理菜单关闭\nDropdownMenuItem 下拉菜单选项\ronClick 点击菜单项后执行\ntext 定义菜单项中显示的内容 需要 Compose 函数而不是 String\nleadingIcon 定义菜单项中前方显示的图标 需要 Compose 函数\ntrailingIcon 定义菜单项中后方显示的图标 需要 Compose 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var menuExpanded by remember { mutableStateOf(false) } IconButton( onClick = { menuExpanded = true } ) { Icon( /* ICON */ ) } DropdownMenu( expanded = menuExpanded, onDismissRequest = { menuExpanded = false } ) { DropdownMenuItem( onClick = { /* TODO */ }, text = { Text( text = \u0026#34;关于\u0026#34; ) }, leadingIcon = { Icon( /* ICON */ ) } ) } 官方文档: 菜单 | Jetpack Compose | Android Developers\nModifier 修饰符\r官方文档:\nCompose 修饰符列表 | Jetpack Compose | Android Developers\n状态\r在 Jetpack 中，我们需要使用 remember 关键字来设置一个可变状态\n可变状态\rremember\rremember 是一个 Composable 函数，它用于在重组过程中记住一个值。当一个 Composable 重组时， remember 会返回它在上次重组时记住的相同值。如果没有 remember , 每次重组时，局部变量都会被重新初始化而导致状态丢失\n若需使用 remember 需要导入:\n1 2 3 import androidx.compose.runtime.getValue import androidx.compose.runtime.setValue import androidx.compose.runtime.remember mutableStateOf\rmutableStateOf 是一个函数，用于创建一个 MutableState 实例。其接收一个初始值，并返回一个可观察的对象。当 MutableState 的 value 改变时，所有读取该 value 的 Composable 都会被标记为需要重组\n在函数体中， mutableStateOf 为创建一个可观察的 MutableState\u0026lt;T\u0026gt; 对象。当 MutableState 中的值改变时，Compose 会自动触发依赖该状态的可组合函数的重组\n声明 MutableState 对象的方法有如下 (default 为默认值):\nval mutableState = remember { mutableStateOf(default) }\nvar value by remember { mutableStateOf(default) }\nval (value, setValue) = remember { mutableStateOf(default) }\n例如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var name_state by remember { mutableStateOf(\u0026#34;\u0026#34;) //使用remember和mutableStateOf创建一个可变状态变量 } Text(\u0026#34;Hello $name_state\u0026#34;) // 假设我们要设定让用户输入的内容更改到该Text上: OutlinedTextField( //文本输入框 value = name_state,s //原本文本框是无状态的， // 然后我们使用remember和mutableStateOf创建了一个 // 可变状态变量name_state 并分配给它 onValueChange = { //当输入框的值改变时调用 name_state = it //更新状态 }, label = { Text(\u0026#34;请输入:\u0026#34;) } //标签文本 ) 官方文档: 状态和 Jetpack Compose | Android Developers\n导航\r导航 | App architecture | Android Developers\n","date":"2025-06-17T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/129202495_p0.webp","permalink":"https://blog.candquarzy.top/p/jetpack-compose%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"Jetpack Compose学习总结"},{"content":"书写位置与顺序\r内部样式表\r在 \u0026lt;title\u0026gt; 标签下方添加 \u0026lt;style\u0026gt; 双标签，在 \u0026lt;style\u0026gt; 标签内书写 CSS 代码\n1 2 3 4 5 6 7 \u0026lt;title\u0026gt;网站标题\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /*选择器{}*/ { css属性 } \u0026lt;/style\u0026gt; 选择器 要美化的目标标签 外部样式表\r将 CSS 代码单独放在 CSS 标签中，然后在 HTML 内使用 \u0026lt;link\u0026gt; 单标签引用\n1 \u0026lt;link rel = \u0026#34;stylesheet\u0026#34; href = \u0026#34;FilePath\u0026#34;\u0026gt; FilePath CSS 的文件路径，通常使用绝对路径 行内样式\r1 2 3 \u0026lt;p style = \u0026#34;font-size: 30\u0026#34;\u0026gt; 我是正文 \u0026lt;/p\u0026gt; 即将 CSS 样式添加在标签内\n书写顺序\r通常有如下顺序：\n盒子模型属性\n文字样式\n圆角等修饰属性\n选择器\r标签选择器\r以标签们作为选择器，选中同名标签并设置相同的样式。\n1 2 3 h1 { color: pink; } 类选择器\r通过归类，分组来差异化设置标签的显示效果\n我通常称为命名选择器\n1 2 3 .pink { color: pink; } 然后在标签内添加 class = \u0026quot;类名\u0026quot; 属性来使该标签使用该选择器\n1 \u0026lt;div class = \u0026#34;pink\u0026#34;\u0026gt; 我是粉色的哦 \u0026lt;/div\u0026gt; 可以在一个标签上使用多个类选择器，使用空格分开\n1 \u0026lt;div class = \u0026#34;avatar color size\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ID 选择器\r和类选择器一样，不过通常 id 选择器适用于配合 JS 使用。但是同一个 id 选择器在一个页面只能使用一次\n1 2 3 4 #avatar_114514 { wight: 300px; height: 300px; } 然后在标签内添加 id = \u0026quot;id名\u0026quot; 属性来使该标签使用该选择器\n1 \u0026lt;div id = \u0026#34;avatar_114514\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; 通配符选择器\r用于将页面内所有标签设置相同的样式\n1 2 3 * { color: red; } 后代选择器\r选中父元素里的所有子元素\n1 2 3 div span { color: red; } 子代选择器\r选中父元素中最近的子元素\n1 2 3 div \u0026gt; span { color: red; } 并集选择器\r选中多组标签设置相同的样式\n1 2 3 div, p, span { color: red; } 交集选择器\r选中同时满足多个条件的元素\n1 2 3 p.box { color: red; } 选择器之间连写，没有任何符号。如果交集选择器中有标签选择器，标签选择器必须书写在最前面\n结构伪类选择器\r根据元素的结构关系查找元素\nE.first-child 查找第一个 E 元素\nE.last-child 查找最后一个 E 元素\nE.nth-child(N) 查找第 N 个 E 元素 (首元素为 1)\n其中 E 为标签名\n1 2 3 li:first-child { background-color: pink; } 上面表示了为第一个 \u0026lt;li\u0026gt; 标签应用特别样式\n关于 nth-child (N) 里的 N:\nN 为公式，如：\n2n 为偶数标签，选中所有的偶数次标签\n2n+1 / 2n-1 为奇数标签，选中所有的奇数次标签\n5n 以 5 为倍数的标签\nn+5 找到第 5 个以后的标签 (此处的 n 从 0 开始计算)\n-n+5 找到 5 个之前的标签 (此处的 n 从 0 开始计算)\n伪类选择器\r伪类表示元素状态，选中元素的某个状态设置样式\n1 2 3 4 5 6 a:hover { color: red; } a:link { color: pink; } 选择性:link 访问前显示的样式\n选择性:visited 访问后改变的样式\n选择性:active 点击时的样式\n选择性:hover 鼠标悬停状态\n如果要给超链接设置以上 4 种状态，需要按照 link \u0026gt; visited \u0026gt; hover \u0026gt; active 的顺序书写，否则可能导致不生效\n伪元素选择器\r创建虚拟元素 (伪元素)，用来摆放装饰性内容\nE::before 在 E 元素里面的最前面添加一个伪元素\nE::after 在 E 元素里面的最后面添加一个为元素\n必须设置 content:\u0026quot;\u0026quot; 属性，用来设置伪元素的内容。如果没有内容，可以留空 (content 为显示文字) 2. 伪元素默认是行内显示模式 3. 伪元素选择器的权重与标签选择器相同 CSS 特性\rCSS 继承性\r子级标签默认继承父级的文字控制属性\n若标签自带属性会优先使用自己的样式，再继承父级样式\nCSS 层叠性\r相同属性 覆盖，后面的 CSS 属性会覆盖前面的 CSS 属性 (优先后者)\n不同属性 叠加，不同的 CSS 属性都生效\nCSS 优先级\r当一个标签使用了多种选择器时，基于不同种类的选择器的匹配规则。通常按照谁优先级高谁生效 (并非按照书写顺序来)\n通配符选择器 \u0026lt; 标签选择器 \u0026lt; 类选择器 \u0026lt; id 选择器 \u0026lt; 行内样式 \u0026lt; !important\n即：选择器选中的范围越大，优先级就越低\n!important\r如果是复合选择器，则需要权重累加计算\n行内样式 \u0026gt; id 选择器个数 \u0026gt; 类选择器个数 \u0026gt; 标签选择器个数\n而 !important 的权重最高，继承权重是最低的\nCSS 属性\r大小、颜色属性\rcolor 颜色属性 (针对字体)。可以使用颜色英文关键词 (如 red,green,blue,pink)、RGB 表示法 (r,g,b 表示红绿蓝三原色，取值 0-255)、RGBA 表示法 (r,g,b,a r,g,b 同上，a 表示透明度，取值 0-1)、十六进制表示法 (#RRGGBB, 如 #FD81AC)\nwidth 宽度，常用单位 px\nheight 高度，常用单位 px\n1 2 3 4 5 div { width: 300px; height: 300px; color: pink; } 字体属性\rfont-size 字体大小，单位 px (默认 p 标签的大小为 16px)\nfont-weight 文字粗细 (正常 400、加粗 700)\nfont-style 字体倾斜 (正常:normal、倾斜:italic)\nline-height 行高 (设置多行文本的间距：数字 + px / 数字 + 当前标签 font-size 属性值的倍数；行号垂直居中可以设置属性值为盒子高度的属性值，仅能对单行文字垂直居中)\nfont-family 字体族 (可以书写多个字体名，每个字体名用逗号隔开，浏览器会从左到右依次查找字体)\ntext-indent 文本首行缩进 (属性值:数字 + px / 数字 + em,em 为当前标签字号大小)\ntext-align 对齐方式 (left 默认左对齐 center 居中对齐 right 右对齐)\ntext-decoration 修饰线 (none 无，去除默认修饰线效果 line-through 删除线 underline 下划线 overline 顶划线)\n1 2 3 4 5 6 7 8 9 p { font-size: 20px; font-weight: 700; font-style: normal; line-height: 50%; font-family: MiSans; text-indent: 2em; text-align: center; } 或者使用 font 的复合属性，其格式为:\n1 font: 是否倾斜 是否加粗 字号/行高 字体 必须按照顺序书写，其中字号和字体是必须项，否则无法生效\n1 2 3 p { font: italic 700 30px/2 Misans; } 背景属性\rbackground-color 背景色\nbackground-image 背景图，属性值为 url (path)\nbackground-repat 背景图平铺方式 (默认为 repeat 平铺；no-repeat 为不平铺，默认在左上角显示；repeat-x X 水平方向平铺；repeat-y Y 垂直方向平铺)\nbackground-position 背景图位置 (关键字:left 左侧；right 右侧；center 居中；top 顶部；botton 底部。坐标：数字 + px, 正负取值均可，0 0 表示左上角)(关键字取值方式写法，可以颠倒取值顺序\n可以只写一个关键字，另一个方向默认为居中，数字只写一个值表示水平方向，垂直方向为居中)\nbackground-size 背景图缩放 (关键字:cover 等比缩放背景图片以完全覆盖，可能导致背景图有部分看不到；contain 等比例缩放背景图片以将图片完全装入背景区，可能导致背景区域部分空白。百分比：根据盒子尺寸计算图片大小)\nbackground-attachment 背景图固定 (属性值:fixed)\n1 2 3 4 5 6 7 div { background-image: url(./hello.png); background-repeat: no-repeat; background-position: center; background-size: contain; background-attachment: fixed; } 或者使用 background 的复合属性，其格式为:\n1 background: 背景色 背景图 背景图平铺方式 背景图位置/背景图缩放 背景图固定 使用空格隔开各个属性值，不区分数据\n1 2 3 div { background: pink url(./hello.png) no-repeat center contain fixed; } 显示模式与转换\r布局网页的时候，根据标签的显示模式来选择合适的标签摆放内容\n块级元素 独占一行，宽度默认是父级的 100%，添加宽高属性生效 (如 \u0026lt;div\u0026gt;)\n行内元素 一行共存多个，尺寸由内容撑开，宽高属性不生效 (如 \u0026lt;span\u0026gt;)\n行内块元素 一行共存多个，默认尺寸由内容撑开，加宽高生效 (如 \u0026lt;img\u0026gt;)\n我们可以使用 display 属性将标签的显示模式进行转换\n属性值:\nblock 块级\ninline 行内\ninline-block 行内块\n1 2 3 div { display: inline; } 盒子模式\r盒子的内容区域由宽、高、文字、图片的尺寸组成\n我们可以设定一个盒子的大小，使用 width (宽度) 和 height (高度) 属性\n边框线 - border\r1 border: 粗细(px) 线条样式 颜色 粗细 边框线的粗细，单位 px\n线条样式 solid: 实线 dashed: 虚线 dotted: 点线\n颜色 十六进制 / RGBA 格式\n这三属性值不区分顺序\n1 border: 1px solid black; 也可以对单独某一方向设置边框线\nborder-top 上方向\nborder-right 右方向\nborder-bottom 底方向\nborder-left 左方向\n1 2 3 4 border-top: 1px solid black; border-right: 2px dashed red; border-bottom: 5px dotted green; border-left: 10px solid pink; 内边距 - padding\r向 4 个方向添加内边距 (单位 px)，会出现在内容与盒子边缘之间，且默认会撑大盒子\n和 border 一样，也可以单独设置某一方向的内边距\npadding-top 上方向\npadding-right 右方向\npadding-bottom 底方向\npadding-left 左方向\n不过 padding 可以设置多个值\n取值个数 示例 释义 1 padding: 10px; 四个方向均为 10px 2 padding: 10px 8px; 上下为 10px 左右为 8px 3 padding: 10px 4px 8px; 上 10px 左右 4px 下 8px 4 padding: 10px 4px 20px 8px; 上 10px 右 4px 下 20px 右 8px 外边距 - margin\r向 4 个方向添加外边距 (单位 px)，会出现在盒子边缘，且默认会撑大盒子\n和 border 一样，也可以单独设置某一方向的内边距\nmargin-top 上方向\nmargin-right 右方向\nmargin-bottom 底方向\nmargin-left 左方向\nmargin 也可以设置多个值\n取值个数 示例 释义 1 margin: 10px; 四个方向均为 10px 2 margin: 10px 8px; 上下为 10px 左右为 8px 3 margin: 10px 4px 8px; 上 10px 左右 4px 下 8px 4 margin: 10px 4px 20px 8px; 上 10px 右 4px 下 20px 右 8px 常用 版心居中: margin: 0 auto; 盒子要有宽度才可以设置版心居中\n盒子尺寸\r盒子的最终尺寸 = 内容尺寸 + border 尺寸 + 内边距尺寸\n由于部分属性值可能会撑大盒子，这可能并不是我们想要的尺寸，因此有如下解决方式：\n手动计算解决\n内减模式：添加 box-sizing: border-box; 属性\n内容溢出 - overflow\r控制溢出元素内容的显示方式\n1 overflow: hidden; 属性值:\nhidden 隐藏溢出的内容\nscroll 添加一个滚动条来控制溢出内容 (无论是否溢出，都会显示显示滚动条)\nauto 超出后添加滚动条\n外边距合并现象\r垂直排列的兄弟元素，上下 margin 会合并 (结果取 margin 中的较大值生效)\n1 2 3 4 5 6 7 .one { margin-bottom: 50px; } .two { margin-top: 20px; } 如上面的代码所示，生效的是 50px\n外边距塌陷问题\r父子级关系标签，子级添加上外边距会产生塌陷问题，会导致父级一起向下移动\n解决方式:\n取消子级 margin，仅父级设置 padding\n父级设置 overflow: hidden;\n父级设置 border-top 属性\n圆角 - border-radius 不是援交\r设置元素的外边框为圆角\n1 border-radius: 25%; 属性值:\n数字 + px\n百分比\n属性值可以写 4 个，从左上角顺时针依次赋值。没有取值的角与对角的取值相同\n1 border-radius: 25% 30% 10% 20%; 全圆: 设置为 50%，而该属性的属性值最高也是 50%;\n胶囊形状: 将长方形盒子设置圆角属性值为盒子高度的一半\n阴影 box-shadow\r给元素设置阴影效果\n1 box-shadow: 3px 2px 30px 50px 20px pink; 属性值从左到右依次为:\nx 轴偏移量 (必须)\ny 轴偏移量 (必须)\n模糊半径\n扩散半径\n颜色\n内外阴影 默认外阴影，内阴影需添加 inset\n浮动 - float\r让块元素水平排列\n属性值:\nleft 在屏幕上左对齐\nright 在屏幕上右对齐\n特点: 顶对齐，具备行内块显示模式的特点\n清除浮动\r浮动元素会脱标，如果父级没有高度，子级无法撑开父级高度，就可能导致页面布局错乱。因此需要清除浮动来解决\n额外标签法 在父元素内容的最后添加一个块级元素，设置 CSS 属性 clear: both;\n单伪元素法 添加一个伪元素清除浮动:\n1 2 3 4 5 .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; } 双伪元素法 (推荐) 添加两个伪元素清除浮动: 1 2 3 4 5 6 7 8 .clearfix::before, .clearfix::after { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { clear: both; } overflow 在父元素添加 CSS 属性: overflow: hidden; 垂直对齐方式 - vertical-align\r基线，默认文字和图片都按基线对齐\n在这一行谁占的高度最大，就给谁加\n属性值:\nbaseline 基线对齐 (默认)\ntop 顶部对齐\nmiddle 居中对齐\nbottom 底部对齐\n过渡属性 - transition\r可以为一个元素在不同状态之间切换的时候添加过渡效果\ntransition 只能设置给元素本身\n属性值:\n要展示过渡的属性\n过渡动画显示时间\n1 2 3 4 5 img { width: 200px; height: 200px; transition: all 1s; } 透明度 - opacity\r设置整个元素的透明度（包含背景和内容）\n属性值: 0-1 (0 时不透明度为 0%，1 时不透明度为 100%)\n光标类型 - cursor\r鼠标悬停在元素上时指针显示样式\n属性值:\ndefault 通常为箭头 (默认)\npointer 小手，提示用户可以点击\ntext 工字型，提示用户可以选择文字\nmove 十字光标，提示用户可以移动\nflex\rflex 布局也叫弹性布局，是浏览器提倡的布局模型，非常适合结构化布局，提供了强大的控件分布和对齐能力\n且 flex 模型不会产生浮动布局中脱标现象\nflex 组成\r如果给父元素设置 display: flex\n那其子元素就可以自动挤压或拉伸\n组成部分:\n弹性容器 (父级)\n弹性盒子 (子级 默认沿着主轴方向排列)\n主轴: 默认在水平方向\n侧轴 / 交叉轴: 默认在垂直方向\nflex 布局\r主轴对齐方式 justfy-content\r属性值:\nflex-start 默认值，弹性盒子从起点开始依次排列\nflex-end 弹性盒子从终点开始依次排列\nspace-between 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间\nspace-around 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧\nspace-evenly 弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等\n侧轴对齐方式 align-items (父级) /align-self (子级)\r属性值:\nstretch 弹性盒子沿着侧轴线被拉伸至铺满容器 (弹性盒子没有设置侧轴方向尺寸则默认拉伸，且弹性盒子在侧轴方向没有尺寸才能拉伸)\ncenter 弹性盒子沿侧轴居中排列\nflex-start 弹性盒子从起点开始依次排列\nflex-end 弹性盒子从终点开始依次排列\n修改主轴方向 (侧轴自动变换到水平方向)\r属性值:\nrow 水平方向，从左向右 (默认)\ncolumn 垂直方向，从上向下 (常用)\nrow-reverse 水平反向，从右向左\ncolumn-reverse 垂直反向，从下向上\n弹性盒子换行 flex-wrap\r弹性盒子可以自动挤压或拉伸，默认情况下，所有弹性盒子都在一行显示\n属性值:\nwrap 换行\nnowrap 不换行（默认）\n行对齐方式 align-content\r该属性值对单行的弹性盒子不生效\n属性值:\nflex-start 默认值，弹性盒子从起点开始依次排列\nflex-end 弹性盒子从终点开始依次排列\ncenter 弹性盒子沿主轴居中排列\nspace-between 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间\nspace-around 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧\nspace-evenly 弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等\n定位\r灵活的改变盒子在网页中的位置\n步骤：\n设置定位模式 添加 position 属性值\n设置边偏移 设置盒子的位置 (方向的英文单词为属性值)\n1 2 position: relative; top: 100px; 相对定位\r改变位置的参照物是自己原来的位置，且不脱标，不占位；标签显示模式不会被改变\n1 position: relative; 绝对定位\r1 position: absolute; 特点:\n脱标不占位\n参照物：先找最近的已经定位的祖先元素，如果祖先元素都没有定位，那么将会参照浏览器可视区域改变位置\n显示模式特点改变：宽高生效 (具备行内块的特点)\n常见用法: 子级绝对定位，父级相对定位 (否则会跑去参照浏览器窗口定位)\n定位居中\r实现步骤:\n绝对定位\n水平、垂直边偏移为 50%\n子级向左和向上移动自身尺寸的一半\n1 2 3 4 position: absolute; left: 50%; top: 50%; transfrom: translate(-50%, -50%); 固定定位\r1 position: fixed; 特点:\n脱标，不占位\n参照物：浏览器窗口\n显示模式会被改变为行内块特点\n堆叠层级 z-index\r默认按照标签书写顺序，后来者居上\n而 z-index 就是设置定位元素的层级顺序，改变定位元素的显示顺序\nint 形数 默认为 0，取值越大越靠上 CSS 精灵图\r即将一堆贴图放在一个图片文件上\n实现步骤:\n创建盒子，盒子尺寸与小图 (贴图) 尺寸相同\n设置盒子背景图为精灵图\n添加 background-position 属性，改变背景图位置 (使用软件测量小图片左上角坐标；将坐标取负数为 background-position 属性值 (向左上移动图片位置))\n字体图标\r实现步骤:\n引入字体样式表 (比如:iconfont.css)\n标签使用字体图标类名\n1 2 3 4 5 6 \u0026lt;head\u0026gt; \u0026lt;link rel = \u0026#34;stylesheet\u0026#34; href = \u0026#34;./iconfont/iconfont.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;span class = \u0026#34;iconfont icon-xxx\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; 如果调整字体大小，注意选择器的优先级，要高于 iconfont 类\n平面转换\r为元素添加动态效果，一般与过渡配合使用。改变盒子在平面内的形态 (如位移，旋转，缩放，倾斜)\n平移 - translate\r属性值: transform: translate(x轴移动距离, y轴移动距离);\n取值:\n像素单位数值 (如 50px)\n百分比 (-50%) 参照盒子大小作为计算\ntranslate() 可以只写一个值，表示仅沿着 X 轴移动\n也可以单独设置\nX 轴 translateX() Y 轴 translateY() 平移实现居中效果: transform: translate(-50%, -50%);\n旋转 - rotate\r属性值: transform: rotate(旋转角度);\n取值单位: deg (值为正，表示顺时针旋转；若值为负，表示逆时针旋转)\n改变转换原点\r默认情况下，转换原点为盒子中心点。若要修改:\n1 transform-origin: 水平原点位置 垂直原点位置; 取值:\n方位名词 (left top right bottom center)\n像素单位数值\n百分比\n多重转换\r必须先平移后旋转\n1 transform: translate() rotate(); 因为旋转会改变坐标轴向\n多重转换一第一种转换形态的坐标轴为准\n必须写复合属性，如果拆开写，由于 transform 有层叠性，只实现最下面的效果\n缩放 - scale\r可通过修改宽高尺寸的方式来实现缩放，但是是从左上角开始缩放\n属性值: transform: scale(缩放倍数);\n缩放倍数可分开设置 X 和 Y 轴\n1 transform: scale(0.5); 取值大于 1 表示放大，小于 1 表示缩小\n倾斜 - skew\r属性值: transform: skew(角度度数);\n角度度数单位 deg\n线性渐变 - linear-gradient\r属性: backgroud-image: linear-gradient();\n属性值:\n1 backgroud-image: linear-gradient(渐变方向, 颜色1 终点位置, 颜色2 终点位置); 渐变方向 (可选) to + 方位名词 ( to right ) / 角度度数 (单位 deg)\n终点位置 (可选) 百分比\n颜色 颜色名称 / 十六进制 / RGBA\n属性值之间用逗号隔开，最后一个值不需要加逗号\n1 backgroud-image: linear-gradient(to right, pink 30%, white 70%); 径向渐变 - radial-gradient\r属性: backgroud-image: radial-gradient();\n属性值:\n1 backgroud-image: radial-gradient(半径 at 圆心位置, 颜色1 终点位置, 颜色2 终点位置); 半径 可以是两条 (为椭圆)\n圆心位置 像素单位 / 百分比 / 方位名词\n终点位置 (可选) 百分比\n颜色 颜色名称 / 十六进制 / RGBA\n空间转换\r空间转换也叫 3D 转换\n属性: transform\n平移 - translate3d\r1 transform: translate3d(x, y, z); x y z 3 个值必须全写才能生效，由于电脑是 2D 平面因此无法观察 Z 轴平移效果\n也可以单独设置某个轴\n1 2 3 transform: translateX(); transform: translateY(); transform: translateZ(); **属性值:**像素单位 / 百分比 (正负均可)\n视距 - perspective\r指定观察者与 Z=0 平面的距离，为元素添加透视效果\n1 transform: perspective(1000); 属性值:建议设定为 800-1200\n该属性需添加至父级\n旋转 - rotate\r1 2 3 transform: rotateX(); transform: rotateY(); transform: rotateZ(); 属性值: 角度 (deg)\n3D 旋转 - rotate3d\r1 rotate3d(x, y, z, 角度度数); 属性值:\nx,y,z 取值为 0-1\n角度度数 单位 deg\n立体呈现 - transform-style\r设置元素的子元素是位于 3D 空间中还是平面中\n属性值:\nflat 子级处于平面中\npreserve-3d 子级处于 3D 空间\n1 transform-style: preserve-3d; 该属性添加给父级\n缩放 - scale3d\r可通过修改宽高尺寸的方式来实现缩放，但是是从左上角开始缩放\n属性值: transform: scale3d(x, y, z);\n缩放倍数可分开设置 X、Y 轴和 Z 轴\n1 2 3 4 5 transform: scale3d(); transform: scaleX(); transform: scaleY(); transform: scaleZ(); 取值大于 1 表示放大，小于 1 表示缩小\n动画\r定义动画\r格式 1:\n1 2 3 4 @keyframes Animation_name{ form{} to{} } 格式 2:\n1 2 3 4 5 6 @keyframes Animation_name{ 0%{} 10%{} .... 100%{} } Animation_name 为动画名称，可自定义 使用动画 - animation\r1 animation: 动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕时状态; 也可使用拆分写法:\nanimation-name (必须) 动画名称\nanimation-duration (必须) 动画时长\nanimation-delay 延迟时间\nanimation-fill-mode 动画执行完毕时的状态 ( forwards 最后一帧状态； backwards 第一帧状态)\nanimation-timing-function 速度曲线 ( steps(数字) 数字为多少步)\nanimation-iteration-count 重复次数 (值为数字或者 infinite 重复播放)\nanimation-direction 动画执行方向 ( alternate 为反向)\nanimation-play-state 暂停动画 ( paused 为暂停，通常配合 :hover 使用)\n逐帧动画\r备显示区域 盒子尺寸与一张精灵图的小尺寸相同\n定义动画 移动背景图 (移动距离 = 精灵图宽度)\n使用动画 steps(N) N 为精灵小图的个数相同\n多组动画\r1 animation: 动画1,动画2,动画n; 若开始动画的代码和默认样式的代码一样，可以省略\n1 animation: run 1s steps(12) infinite, move 3s linear forwards; ","date":"2025-04-21T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/124928964_p0.webp","permalink":"https://blog.candquarzy.top/p/css%E6%A0%B7%E5%BC%8F%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/","title":"CSS样式标签总结"},{"content":"HTML 骨架\rHTML 的基本骨架是网页模板\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;网页标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 网页主体 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; html 整个网页\nhead 网页头部，用于存放给浏览器看的代码，例如 CSS\nbody 网页主体，用于存放给用户看的代码。比如图片，文字等信息\ntitle 网站的标题，显示在标签页\n使用 \u0026lt;!--注释内容--\u0026gt; 来注释内容\nVSCode 中快速生成 HTML 基本骨架：\n在 HTML (.html) 文件中，使用英文!配合 Enter/Tab 键\n标题标签\r1 2 3 4 5 6 7 8 9 10 \u0026lt;h1\u0026gt; 大标题 \u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;/h2\u0026gt; ... \u0026lt;h6\u0026gt; \u0026lt;/h6\u0026gt; \u0026lt;h1\u0026gt; ~ \u0026lt;h6\u0026gt; 标题标签，大小从 h1 -\u0026gt; h6 最小。均为独占一行 一般 \u0026lt;h1\u0026gt; 标签在一个网页中只使用一次，用来存放新闻标题或网页 logo\n段落标签\r1 2 3 \u0026lt;p\u0026gt; 我是正文 \u0026lt;/p\u0026gt; 独占一行，且段落之间存在间隙\n换行\r1 \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; 换行标签，单标签。要使用 br 标签来进行换行，浏览器不识别代码中的 Enter 换行符 水平线\r1 \u0026lt;hr\u0026gt; \u0026lt;hr\u0026gt; 水平线标签，单标签。可以将两部分内容隔开一条线\n文本格式化标签\r1 2 3 4 5 6 7 \u0026lt;b\u0026gt; 加粗文字 \u0026lt;/b\u0026gt; \u0026lt;strong\u0026gt; 加粗文字 \u0026lt;/strong\u0026gt; \u0026lt;b\u0026gt;…\u0026lt;/b \u0026gt; 或 \u0026lt;strong\u0026gt;…\u0026lt;/strong\u0026gt; 加粗 1 2 3 4 5 6 7 \u0026lt;i\u0026gt; 斜体文字 \u0026lt;/i\u0026gt; \u0026lt;em\u0026gt; 斜体文字 \u0026lt;/em\u0026gt; \u0026lt;i\u0026gt;…\u0026lt;/i\u0026gt; 或 \u0026lt;em\u0026gt;…\u0026lt;em\u0026gt; 斜体 1 2 3 4 5 6 7 \u0026lt;u\u0026gt; 下划线文字 \u0026lt;/u\u0026gt; \u0026lt;ins\u0026gt; 下划线文字 \u0026lt;/ins\u0026gt; \u0026lt;u\u0026gt;…\u0026lt;/u\u0026gt; 或 \u0026lt;ins\u0026gt;…\u0026lt;/ins\u0026gt; 下划线 1 2 3 4 5 6 7 \u0026lt;s\u0026gt; 删除线标签 \u0026lt;/s\u0026gt; \u0026lt;del\u0026gt; 删除线标签 \u0026lt;/del\u0026gt; \u0026lt;s\u0026gt;…\u0026lt;/s\u0026gt; 或 \u0026lt;del\u0026gt;…\u0026lt;/del\u0026gt; 删除线 图像\r1 \u0026lt;img src = \u0026#34;path\u0026#34; alt = \u0026#34;msg\u0026#34; title = \u0026#34;tips\u0026#34; width = \u0026#34;width\u0026#34; height = \u0026#34;height\u0026#34;\u0026gt; 图像标签为单标签，不换行\nsrc (必须) 要显示的图像路径\nalt 为图片无法显示时在界面上所显示的文字\ntitle 为鼠标悬停在图片上时所显示的文字\nwidth 图片宽度，值为数字，不需要写单位 (单位应该是 px)\nheight 图片高度，值为数字，不需要写单位 (单位应该是 px)\n路径\r相对路径\r当前文件夹：./\n上一级文件夹内：…/\n绝对路径\r以 / 开头的为绝对路径\nWindows 系统中，默认是 \\ 其他系统为 / 建议统一使用 /\n超链接\r1 \u0026lt;a href = \u0026#34;link\u0026#34; target = \u0026#34;_blank\u0026#34;\u0026gt;提示文字\u0026lt;/a\u0026gt; link (必须) 跳转到的目标地址，可以是网址，也可以是一个文件 (若内容为 #即为空链接)\ntarget = “_blank” 在新标签页中打开\n音频\r1 \u0026lt;audio src = \u0026#34;link\u0026#34; controls loop autoplay\u0026gt;\u0026lt;/audio\u0026gt; src (必须) 音频的 URL。支持 mp3 ogg wav\ncontrols (可选) 显示音频控制面板\nloop (可选) 循环播放\nautoplay (可选) 自动播放 (为了用户体验，一般浏览器会禁用自动播放功能)\n视频\r1 \u0026lt;video src = \u0026#34;link\u0026#34; controls loop muted autoplay\u0026gt;\u0026lt;/video\u0026gt; src (必须) 视频的 URL。支持 mp4 webm ogg\ncontrols (可选) 显示视频控制面板\nloop (可选) 循环播放\nmuted (可选) 静音播放\nautoplay (可选) 自动播放 (仅支持在静音状态下自动播放)\n毕竟你也不想别人一打开你的网页就被声音吓到吧\n列表\r无序列表\r1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt; ... \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; 无序列表\n\u0026lt;li\u0026gt; 列表项目\n\u0026lt;ul\u0026gt; 标签内只能包含 \u0026lt;li\u0026gt; 标签，而 \u0026lt;li\u0026gt; 标签内可以包含大部分内容\n有序列表\r1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt; ... \u0026lt;/ol\u0026gt; \u0026lt;ol\u0026gt; 无序列表\n\u0026lt;li\u0026gt; 列表项目\n\u0026lt;ol\u0026gt; 标签内只能包含 \u0026lt;li\u0026gt; 标签，而 \u0026lt;li\u0026gt;标签内可以包含大部分内容\n定义列表\r1 2 3 4 5 6 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;列表标题\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;列表描述/详情\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;列表描述/详情\u0026lt;/dd\u0026gt; ... \u0026lt;/dl\u0026gt; \u0026lt;dl\u0026gt; 列表的标题\n\u0026lt;dd\u0026gt; 列表描述 / 详情。默认自动向后缩进\n\u0026lt;dl\u0026gt; 标签内只能包含 dt 和 dd 标签，而 dt 和 dd 标签内可以包含大部分内容\n表格\r1 2 3 4 5 6 \u0026lt;table border = \u0026#34;count\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;表头\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;内容\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; border 为表格添加边框线，默认无边框\ncount 边框线粗细数值\ntable 表格标签\ntr 每一行\nth 表头单元格 (默认字体加粗)\ntd 内容单元格\n合并单元格 - 跨行合并\r有时，需要将多个单元格合并成一个单元格\n首先，要保留最靠左边并且最靠上边的单元格，再添加属性（取值是数字，表示需要合并的单元格数量）\n保留最上单元格，添加属性 rowspan\n1 \u0026lt;td rowspan = \u0026#34;2\u0026#34; \u0026gt; 我是内容咩 \u0026lt;/td\u0026gt; 合并单元格 - 跨列合并\r保留最左单元格，添加属性 colspan\n1 \u0026lt;td colspan = \u0026#34;2\u0026#34; \u0026gt; 我是内容咩 \u0026lt;/td\u0026gt; 不能跨结构标签合并\n表单\r1 \u0026lt;form action = \u0026#34;发送数据的地址\u0026#34;\u0026gt;表单标签代码\u0026lt;/form\u0026gt; 一般会将所有表单标签包括在 form 中，这样后端就可以接收到信息\n手机用户信息使用表单标签。比如登录、注册、搜索等\n表单标签 - input\r1 \u0026lt;input type = \u0026#34;desc\u0026#34; placeholder = \u0026#34;msg\u0026#34;\u0026gt; desc 属性值。有 text (文本框，用于输入单行文本) 和 password (密码框) 两种可选\nmsg 给用户的提示信息\n\u0026lt;input\u0026gt; 标签为单标签，且不会独占一行\n单选框 - radio\r1 \u0026lt;input type = \u0026#34;radio\u0026#34; name = \u0026#34;控件分组\u0026#34; checked\u0026gt; name 控件名称，可以为控件分组 (同组只能选中一个)\nchecked (可选) 默认勾选\n多选框 - checkbox\r1 \u0026lt;input type = \u0026#34;checkbox\u0026#34; checked\u0026gt; 上传文件 - file\r1 \u0026lt;input type = \u0026#34;file\u0026#34; multiple\u0026gt; multiple (可选) 多选文件 下拉菜单\r1 2 3 4 5 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;选项1\u0026lt;/option\u0026gt; \u0026lt;option selected\u0026gt;选项2\u0026lt;/option\u0026gt; ... \u0026lt;/select\u0026gt; select 下拉菜单整体\noption 下拉菜单中的每一项\nselected 默认选中 (若不写该属性默认选中选项 1)\n文本域\r实现多行文本输入的表单控件\n1 \u0026lt;textarea\u0026gt;默认提示文字\u0026lt;/textarea\u0026gt; 默认对该输入框右下角有拖拽功能\nlabel\r给表单标签前面添加说明文本\n支持 \u0026lt;label\u0026gt; 标签增大点击范围的表单控件：文本框，密码框，上传文件，单选框，多选框，下拉菜单，文本域\n写法 1\r\u0026lt;label\u0026gt; 标签只包裹内容，不包裹表单控件\n设置 \u0026lt;label\u0026gt; 标签的 for 属性值和表单控件的 id 属性值相同\n1 2 \u0026lt;input type = \u0026#34;radio\u0026#34; id = \u0026#34;abc\u0026#34;\u0026gt; \u0026lt;label for = \u0026#34;abc\u0026#34;\u0026gt;msg\u0026lt;/label\u0026gt; 写法 2\r使用 \u0026lt;label\u0026gt; 标签直接包裹文字和表单控件，不需要属性\n1 \u0026lt;label\u0026gt;\u0026lt;input type = \u0026#34;radio\u0026#34;\u0026gt;msg\u0026lt;/label\u0026gt; 按钮\r1 2 3 \u0026lt;button type = \u0026#34;desc\u0026#34;\u0026gt; 按钮显示名称 \u0026lt;/button\u0026gt; desc 为属性值，有以下三种情况\nsubmit (默认) 提交按钮，点击后将数据提交到后台\nreset 重置按钮，将表单恢复默认值\nbutton 普通按钮，默认无功能。通常配合 JS 使用\n无语义布局\r1 2 3 \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;我是span\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 布局网页，划分网页区域以摆放内容\n\u0026lt;div\u0026gt; 俗称 \u0026ldquo;大盒子\u0026rdquo;，独占一行\n\u0026lt;span\u0026gt; 俗称 \u0026ldquo;小盒子\u0026rdquo;，不会换行\n字符实体\r在网页中显示预留字符。如果要显示多个空格或者 \u0026lt; , \u0026gt; 等符号就需要字符实体\n\u0026amp;nbsp 空格\n\u0026amp;lt 小于号\n\u0026amp;gt 大于号\n","date":"2025-04-20T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/126612103_p0.webp","permalink":"https://blog.candquarzy.top/p/html%E6%A0%87%E7%AD%BE%E5%A4%A7%E6%B1%87%E5%90%88/","title":"HTML标签大汇合！"},{"content":"docker 服务\r1 systemctl start docker 启动 docker 服务\n1 systemctl stop docker 停止 docker 服务\n1 systemctl restart docker 重启 docker 服务\n1 systemctl enable docker 设置 docker 服务开机自启\ndocker 的使用\r1 docker run [-d] [-v localdata:dockerdir] [--network + network_name] [-p localport:dockerport] [-e KEY = VALUE] [--name repository:tag] -d 让容器在后台静默运行\n-v 映射数据卷；localdata: 本地数据卷 : dockerdir: 容器内目录；本地目录必须以 / 或者 ./ 开头，必须为绝对路径，如果以名称开头就会被识别为数据卷而非本地目录\n–network 网络设置；network_name: 网络名 可以直接在运行时将该容器加入指定网络\n-p 把容器内的内部端口映射到外部机器的端口上；localport: 本机端口 : dockerport: 容器内部端口\n-e 设置环境变量；KEY: 键 : VALUE: 值\n–name 容器名称；repository: 镜像名 : tag: 镜像的版本\n1 docker stop [repository] 停止镜像中的进程\n1 docker start [repository] 启动镜像中的进程\n1 docker ps [-a] -a 查看所有容器的状态 查看容器的运行状态，默认仅查看正在运行的容器\n1 docker logs [-f] [repository] -f 持续输出日志\nrepository 容器名\n输出容器日志\n1 docker exec [-it] [repository] [bash] -it 可对容器内进行命令交互\nbash 任意指令\n进入容器内部执行指令\ndocker 镜像\r1 docker pull [repository] 仅下载镜像\n1 docker images 查看下载的镜像\n1 docker rmi [repository:version] 删除下载的镜像\n1 docker build -t [repository] [dockerfile] dockerfile dockerfile 文件所在的目录 构建镜像\n1 docker save [-o] [name:version] -o 选择保存时命名 保存构建的镜像\n1 docker load [-i / -q] [repository] -i 读 tar 文件\n-q 静默加载\n加载别人构建的对象\n1 docker push 将你的镜像推送上去\ndocker 数据\r数据卷的英文叫：Volume\n这是一个虚拟的目录，是容器里内目录与本机目录之间映射的桥梁，类似于 Windows 的虚拟硬盘\n默认对应的本机系统的目录： var/lib/docker/volumes\n1 docker volume creat [volume] volume 数据卷名 创建数据卷\n1 docker volume ls 查看所有数据卷\n1 docker volume rm [volume] 删除指定数据卷\n1 docker volume inspect [volume] 查看某个数据卷详情\n1 docker volume prune [volume] 清空数据卷\n1 docker inspect [repository] 查看容器详情\ndocker 网络\r默认情况下，所有的容器都是以 bridge 的方式链接到 docker 的一个虚拟网卡上的\n这个网卡的默认网关是 172.17.0.1/16 ，我们也可以自定义\n加入自定义网络的容器可以通过网卡互联，容器名之间可以相互访问\n1 docker network creat [network] network 网络名称 创建一个网络 1 docker network ls 查看所有网络\n1 docker network rm [network] 删除指定网络\n1 docker network prune 删除未使用网络\n1 docker network connect [network] [repository] repository 容器名称 使指定容器加入指定网络\n1 docker network disconnect [network] [repository] 使指定容器离开某网络\n1 docker network inspect 查看网络的详细信息\ndocker - compose\rdocker compose 通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器，可以实现多个相互关联容器的快速部署\n1 docker compose [command] [options] options：\n-f 指定 compose 文件的路径及名称\n-p 指定 project 名称\n-d 后台静默运行\ncommand：\nup 创建并启动所有容器\ndown 停止并移除所有容器与网络\nps 列数所有启动的容器\nlogs 查看指定容器的日志\nstop 停止容器\nstart 启动容器\nrestart 重启容器\ntop 查看运行的进程\nexec 在指定的正在运行的容器种执行命令\n","date":"2025-03-11T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/112614928_p1.webp","permalink":"https://blog.candquarzy.top/p/docker%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/","title":"docker指令记录"},{"content":"登录\r普通登录\r1 ssh username@IP -p port username 用户名\nIP 服务器 IP\nport 登录端口\nexit / ctrl + D 可以退出本次登录\nROOT 用户登录\r以下方法仅第一次可用：\n登录用户账户\n执行命令 sudo passwd root\n会出现 [sudo]password for username:\n输入目前登录用户的账户和密码\n当显示 NewPassword: 时输入新的 ROOT 账户的密码\nRetype New Password: 再次输入刚刚设定的 ROOT 账户密码进行确认\n即可重置 ROOT 账户的密码\n接着执行命令 su - root 即可切换为 ROOT 账号\n文本编辑器 vi\rvi 文件\r如果命令指定的文件不存在，则创建文件\n如果命令指定的文件存在，则打开该文件\n命令模式\rh 光标左移一个字符\nj 光标下移一个字符\nk 光标上移一个字符\nl 光标右移一个字符\nx 删除光标所在字符\ndd 删除光标所在行\nndd n 为数字，表示删除当前光标及下面的 n 行\ndG 删除当前行以下的所有内容\nd$ 删除当前光标到当前光标所在行的结尾\nd0 删除当前光标到当前光标所在行的开头\ndw 删除光标处到词尾的内容\ngg 把光标移到文件开始的位置\nG 将光标移到文件末尾\nctrl + F 上一页\nctrl + B 下一页\n0 把光标移动到所在行的行首\n$ 把光标移动到所在行的行尾\npageup 向上翻页\npagedown 向下翻页\nyy 复制光标所在行\np 粘贴\nv 移动光标进入选择模式\ny 复制选中的内容\nnyy n 为数字，表示复制当前光标及下面的 n 行\nu 撤销刚才的操作\nctrl + R 恢复更改\n. 重复刚才所做的操作\n插入模式\r按下键盘上的 i 进入插入模式，在左下角会显示 -- INSERT -- 字样\n按下键盘上的 a 也可以进入插入模式，不过是在光标后面插入内容\n0 在光标上一行之后插入一行\no 在光标所在行之后插入一行\nl 在行的开头进入插入模式\nA 在行的结尾进入插入模式\nesc 退出插入模式，进入命令模式\n底行模式\r:wq 保存文件并退出\n:w 保存文件但是不退出 vi\n:q! 不保存文件强制退出编辑器\n:set paste 设置粘贴模式 (用于从外部复制内容进来不会导致内容错乱)\n:set nu 显示行号\n:set nonu 关闭行号显示\nvi 编辑器其他\r/[string] string 代表需要查询的内容 比如 /abc 即查询 abc\nn 查找下一个\nN 查找上一个\n替换内容\r1 :[range]/[string]/[replace]/[mode] range 查找要替换内容的范围\nstring 要被替换的内容\nreplace 替换后的内容\nmode 替换模式\n文件系统\rLinux 的文件路径是区分大小写的\n可以通过 pwd 查询当前工作目录\ncd 命令 - 更改工作目录\rcd / 路径 / 改变工作目录\ncd… 回到上一级目录\n绝对路径与相对路径\r绝对路径 开始于根目录，沿着目录层级，一直到达想要的目录或文件\n相对路径 相对的当前目录 其中 . 指的是当前目录 … 指的是上一层目录，即当前目录的父目录\n./test.txt 在当前目录下寻找 test.txt\n./ 路径 / 路径 / 文件 也可以打开路径 / 路径 / 文件\n…/ 文件 打开上一层目录中的某文件\n…/…/…/文件 打开上 3 层目录中的文件\nls 命令 - 查看文件 / 文件夹\r查看目录下的文件 / 文件夹\n1 ls [-a / -l / -h] [dir] -a all，列出所有文件\n-l 以列表形式展示内容，并显示更多信息 可以简写为 ll\n-lh 显示文件，文件夹大小\n-la 查看隐藏的文件详情\ndir 目录\n通过 ls 来确定当前的工作目录并不恰当，我们可以使用 pwd 来查看当前所在的工作目录\ncp 命令 - 复制\r复制命令\n1 cp [-r] [source] [destination] -r 拷贝目录 同时会将该目录下的所有文件和文件夹都拷贝过去\nsource 源文件 / 目录\ndestination 目的文件 / 目录\n1 cp /data/config.yaml ./config/ cp 命令也可以使用通配符\nmv 命令 - 移动 / 重命名\r移动 / 重命名命令\n1 mv [source] [destination] source 要被移动的源文件 / 目录\ndestination 目标目录 / 文件新名称 / 目录的新名称 (要求该目录不存在)/ 要移动进去的目录 (要求该目录存在)\ngrep 命令 - 查找\r在文件中查找字符串\n1 grep [keywords] [file] [-n] [-C] [-B] [-A] [line] keywords 要查找的关键字\nfile 被查找的文件\n-n 会将行号和每一行的内容都输出\n-n -C 将查找到所在关键字的这一行的上下 line 行信息都输出出来\n-n -B 将查找到所在关键字的这一行的上面 line 行信息都输出出来\n-n -A 将查找到所在关键字的这一行的后面 line 行信息都输出出来\n1 grep candy Candy_note -n -C 3 wc 命令 - 关键字数量统计\r统计在一个文件中出现的关键字数量\n1 wc [-c -m -l -w] [file] -c 统计字节数量\n-m 统计字符数量\n-l 统计行数\n-w 统计单词数量\nln 命令 - 创建 “快捷方式”\r创建一个类似于 Windows 中的快捷方式\n1 ln -s [source] [destination] source 被链接的文件 / 文件夹路径\ndestination 目的地路径\nscp 命令 - 远程拷贝文件\r从远程设备中拷贝文件过来\n1 scp [localfile][filename] [username]@[address]:[destinationPath] 我们使用 B 主机进行拷贝，就必须要有 B 主机的用户账号。加入 B 主机的账号是 candy1……\n1 scp /home/candy0/note.txt candy1@luckyfuture.cc:/home/candy1/ which 命令 - 查找命令\r可以查到被查找的命令在哪个路径下\n1 which [command] 假如我要查看 ls 命令在哪个路径下：\n1 which ls find 命令 - 查找文件\r查找文件在哪个路径下\n1 find [startPath] -name [\u0026#34;filename\u0026#34;] startPath 起始查找路径\nfilename 文件名\n即从路径开始以文件名查找文件\n也可以使用通配符来查找文件\n1 find [stratPath] -size [+/-] [n] [kMG] stratPath 起始查找路径\n+/- + 代表大于 - 代表小于\nn 代表大小中数字部分\nkMG k: 代表 kb，需小写 k；M: 代表 MB；G: 代表 GB\n用户\rROOT 账号拥有系统的最高权限\n每一个用户账号都对应一个用户 ID，其被存储在文件 /etc/passwd 中\n添加用户\r1 adduser username username 新用户的用户名 如果不添加组参数系统会默认创建一个组\n1 adduser --ingroup root username 直接创建一个属于 root 用户组的用户\n更新用户密码\r如果是非 ROOT 账户，则只能更改自己的密码。ROOT 账户可以更改所有人的密码\n1 passwd username username 要被更改密码的账户名 (仅限 ROOT 账户使用) 删除用户\r1 deluser username username 要被删除的账户名 删除该用户 (仅限 ROOT 账户使用) 切换用户\r1 su [-] username - 使用该用户的用户环境\nusername 要被切换的用户名\n如果是 root 账号切换不需要密码，普通用户则需要密码\n若一直套娃切换，系统会保留层级关系；在使用 ctrl+D 时会退出当前账号返回上一个账号\n1 getent passwd 查看当前系统中有哪些用户\n用户组\r查看所有用户组\r1 groups 查看当前账号用户组\r1 groups [username] username 用户名 查看其他用户所属于的用户组\r1 grep \u0026#39;[keyword]\u0026#39; /etc/group keyword 组名称关键字 查看用户组里的用户，比如查看以 sudo 开头的组的用户：\n1 grep \u0026#39;^sudo\u0026#39; /etc/group 其中，这里的 keyword 可以使用正则表达式\n新增 / 删除用户组\r1 addgroup [NewGroupName] NewGroupName 新增组的名称 新增一个用户组\n1 delgroup [groupname] groupname 要被删除的组名称 删除该用户组\n改变用户所在组\r1 usermod -g [groupname] [username] groupname 组名称\nusername 用户名\n将用户添加的指定的组中\n1 usermod -G [groupname1] [groupname2]… [username] 将用户设定到这些组当中\n权限\r在 Linux 系统中，权限通常可以按照用户权限分为 3 种类型，以及对文件的 3 种权限方式\n用户权限\rowner 即文件的所有者，也是该文件的创建者\ngrouper 文件所有者，即文件所在的用户组及里面的用户\nother 其他用户，即非 owner 和非 grouper\n文件权限\r读 使用英文字母 r 表示，可以查看目录 / 文件内的内容\n写 使用英文字母 w 表示，可以修改文件 / 目录内的内容\n执行 使用英文字母 x 表示，可以执行文件 / 使用 cd 命令进入目录\ndrwxrw-rw-\r权限细节总共分为 10 个位置\n第1位，- 表示文件；d 表示文件夹；l 表示软链接\n第 2-4 位 这三位为文件所属用户权限\n第 5-7 位 这三位位文件所属用户组中的用户权限\n第 8-10 位 其他用户权限\n假设一个权限是 drwxrw-r– 则表示:\nd 这是文件夹 rwx 所属用户权限，在该例子中该文件所有者可以对该文件进行读、写、执行 rw- 所属用户组权限，在该例子中该文件所有者所在的用户组中的用户可以对该文件进行读、写操作 r– 表示其他用户的权限，在该例子中其他用户对该文件仅可读 数字所对应的权限\r0 无任何权限，即 —\n1 仅有 x 权限，即 –x\n2 仅有 w 权限，即 -w-\n3 w 和 x 权限，即 -wx\n4 仅有 r 权限，即 r–\n5 r 和 x 权限，即 r-x\n6 r 和 w 权限，即 rw-\n7 全部权限，即 rwx\n例如， 751 即为 rwx (7) r-x (5) --x (1)\n修改文件访问权限\r1 chmod [-R] [who] [op] [permission] [file/dir] -R 指对文件夹内的全部内容应用相同操作\nwho 表示用户类型 (见下表)\nop 表示动作（+ 表示加上 permission 指定权力，- 表示取消 permission 指定的权力\npermission 存取权限（r: 可读，w: 可写，x: 执行）\n用户类型表\nu: 文件拥有者\ng: 该文件拥有者的同组用户\no: 其他人\na: 所有人\n1 2 3 4 5 6 7 chmod u+w file1 //该命令添加了拥有者对file1文件的写权限 chmod u-x file1 //该命令去掉了拥有者对file1文件的执行权限 chmod ug+rwx file //该命令添加了拥有者和同组用户对file1文件的读、写、执行权限 chmod a+rwx file //该命令添加了所有人对file1文件的读、写、执行权限 当然除了这种方式，我们也可以使用数字进行修改权限的修改\n1 chmod [who] [op] [Num] [file/dir] 比如，给当前目录下的文件添加对自己的 777 权限：\n1 chomod 777 file1 文件归属权\r1 chown [-R] [User][:][UserGroups] [file1] [file2] […] 改变文件所有者及文件所在组的用户\n-R 对文件夹内全部内容应用相同的规则\nUser 修改所属用户\n:UserGroups 修改所属用户组，其中带：的是用户组，不带：的是用户\n1 2 3 4 5 chown candy file1 //把文件file1的所有者变更为用户candy chown candy:sudo file1 //把文件file1的所有者变更为用户candy，所属组变为sudo chown -R candy dir1 //把目录dir及其子目录以及文件的所有者都变更为candy 也可以使用 chgrp 命令改变文件所有者组：\n1 chgrp [opt] [groups] [file] opt 选项\ngroups 组名称\nfile 文件名称\nsudo\rsudo 是以 root 账号的权限执行命令一次\n哪些账户可以使用 sudo 权限来运行是在 /etc/sudoers 里进行配置的\n1 sudo -u [user] [command] user 以该用户的权限来执行命令\ncommand 要执行的命令\n1 sudo [command] 以 ROOT 权限来执行这条命令\n可以直接将某个用户加入 sudo 用户组（使用 usermod 命令添加），就可以在任何地方，以任何账号权限，运行任何程序\n进程\rps 命令 - 进程命令\r1 ps 查看进程信息\n1 ps -f 查看详细的进程信息\n1 ps -u [user] user 用户名 显示该用户所创建的进程信息\n1 ps -e 显示当前所有正在运行的进程信息\n1 ps -ef 显示当前所有正在运行的所有系统进程信息\n1 ps -ef | grep [keyword] keyword 要被查找进程的关键字 查找该进程\n1 ps -ef | grep [keyword] | grep -v [unkeyword] keyword 要被查找进程的关键字\nunkeyword 不包含的（排除）关键字\n查找一个进程，但是这个进程不显示包含排除关键字的进程\nnohup - 静默运行\r一般来说，有些程序如果关闭终端的话进程有可能会被结束掉，因此可以在命令上加上 nohup\n在程序前台运行的情况下，使用快捷键 ctrl+C 终止进程\nkill 命令 - 杀死进程\r1 kill -9 [PID / name] PID / Name 该程序的 PID 或程序名\n-9 表示强行杀死\n重定向\r在 shell 中输入命令时，可以使用 \u0026gt; 符号将输入命令后的执行结果信息输出到指定文件中\n1 ps \u0026gt; [out] 上面的命令会将原本要输出在 stdout（可以理解为终端的输出）输出到文件中\n如果要将 stdout 和 stderr（屏幕显示的报错信息）同时输入到一个文件 err.txt 中可以使用 \u0026amp;\u0026gt; 符号\n1 command \u0026amp;\u0026gt; err.txt 单独重定向 stderr 的符号是 2\u0026gt;\n1 command \u0026gt; [out] 2\u0026gt; err.txt stdin 重定向符号是 \u0026lt; ，可以将原本要显示到终端上的内容输出到文件中\necho 命令\r在命令行内输出指定的内容\n1 echo [string] string 要输出的指定内容 带有空格或 \\ 等特殊符号的内容，建议使用双引号包含。如果不适用双引号的情况下，空格后面很容易被识别为另一个参数，虽然说影响不是很大就是了（\n1 echo `[commad]` commad 被 `` 包含的内容会作为命令去执行，然后结果会被 echo 打印在屏幕上 \u0026gt; 和 \u0026raquo;\r\u0026gt; 将左侧命令的结果覆盖写入到右侧指定的文件中\n\u0026raquo; 将左侧命令的结果追加写入到右侧指定的文件中\ntail 指令\rtail 指令可以查看文件尾部的内容，追踪文件的最新更新。也就是从后向前看\n1 tail [-f] [-num] [filedir] -f 表示持续跟踪\n-num 表示从后向前看多少行，默认 10 行\nfiledir 要查看的文件路径\n例如，查看 text.txt 文件后 5 行的内容\n1 tail -5 text.txt 管道符 |\r在 Linux 操作系统中，有时候需要将一个命令输出的内容作为另一个命令的输入内容，可以使用 | 操作符来实现，并且管道符可以嵌套\n1 icommand | [othercommand1] | [othercommand2] icommand 要输出的命令 othercommand 其他命令 打包与压缩\rtar 命令 - 针对 tar 压缩包\r1 tar [-c -v -x -f -z -C] [para0] [para1] […] -c 创建压缩文件，用于要压缩一个文件的时候\n-v 显示压缩和解压缩的进度\n-x 解压缩而不是压缩\n-f 要创建的文件，或者说要解压文件，-f 选项必须在所有选项中处于最后一个\n-z gzip 模式，不使用 -z 就是普通的 tarball 格式，一般处于第一位\n-C 自定义解压路径\n比如解压一个 test.tar，并将其解压缩到 /home/candy/\n1 tar -xvf test.tar -C /home/candy/ 如果要压缩 /data 路径出来一个名为 data.tar 压缩包……\n1 tar -cvf data.tar ./data/* 也可以仅查看一个压缩包\n1 tar -tvf data.tar 也可以将新文件添加进压缩包中\n1 tar -rvf data.tar my_pic.jpg gzip 命令 - 针对 gz 压缩包\rgz 压缩包可以将压缩包体压缩至很小\n1 gzip -d [file.gz] 解压缩一个名为 file.gz 的压缩包\n同时 gzip 和 tar 可以联合使用\n1 tar -zcvf [pag.tar.gz] [file] [dir] pag.tar.gz 压缩包名\nfile 文件\ndir 目录\n可以直接将文件压缩成.tar.gz 格式\n1 tar -zxvf [pag.tar.gz] 解压缩一个类型为 .tar.gz 的压缩包\nzip 命令 - 针对 zip 压缩包\r1 zip [-r] [file.zip] [dir] -r 压缩目录\nfile.zip 压缩包名\ndir 路径\n压缩一个 zip 格式的压缩包\n1 unzip [file.zip] 解压缩一个 zip 格式的压缩包\n系统相关命令\rtop 命令 - 查看系统进程信息\r1 top [-p -d -c -n -b -i -u] [PID] -p 只显示某个进程的信息\n-d 设置刷新时间，默认是 5s\n-c 显示产生进程的完整命令，默认是进程名\n-n 指定刷新次数，比如 top-n3，刷新输出 3 次后退出\n-b 以非交互非全屏运行，以批次的方式执行 top，一般配合 -n 指定输出几次统计信息，将输出重定向到指定文件\n-i 不显示任何闲置 (idle) 或无用 (zombie) 进程\n-u 查找特定用户启动的进程\n在 top 的页面上，按 1 切换核心的占用情况，按下大写 P 可以按照 CPU 占用率高低来排序，大写 M 按照内存占用高低来排序。按下 q 即可退出\ntop 命令内容较多，这里仅介绍部分内容\n网络相关命令\r1 ip addr 查看网络接口、IP 地址\n1 ping [ip] 连通性测试\n1 hostname 查看主机名\n1 hostnamectl set-hostname [name] 修改主机名为 name\n1 netstat 查看当前所有占用网络端口的程序\n1 netstat -anp | grep [port] port 端口号 查看指定端口的占用情况\n1 netstat [-a -t -u -n -l -p -r] -a 显示所有选项，默认不显示 LISTEN 相关\n-t 仅显示 TCP 相关选项\n-u 仅显示 UDP 相关选项\n-n 不显示端口协议名，显示端口数字\n-l 只显示 Listen (监听) 的状态端口\n-p 显示建立相关链接的进程 PID\n-r 显示路由信息、路由表\nnetstat 命令内容较多，这里仅介绍部分内容\n1 nmap [ip] 显示端口占用情况\n1 sar [-n] DEV [num1] [num2] -n 查看网络\nDEV 查看接口，默认为 DEV 即可\nnum1 数字，表示刷新间隔\nnum2 数字，表示刷新次数\n网络状态监控\nwget /curl 命令 - 网页 / 下载命令\r1 wget [-b] [URL] -b 后台下载，并且将日志写入当前工作目录的 wget-log 文件中\nURL 文件地址\n即可将一个文件下载到当前工作目录\n1 curl [-o] [URL] -o 用于下载文件，当 URL 为文件链接时，可以使用 -o 来保存文件\nURL 要发起请求的网络地址\ncurl 类似于浏览器，可以查看网页，也可以下载文件\nsystemctl 系统服务命令\r用于启动，关闭，重启服务\n1 systemctl status [service] service 服务名 查看该服务状态\n1 systemctl start [service] 启动该服务\n1 systemctl stop [service] 停止该服务\n1 systemctl restart [service] 重启该服务\n1 systemctl enable [service] 开启服务开机自启动\n1 systemctl disable [service] 关闭服务开机自启动\napt / yum 服务\r1 apt install [package] package 要安装软件的包名 安装一个软件包\n1 apt list --installed 显示所有已经安装的程序包\n1 apt list [package] 显示 package 程序包的安装情况\n1 apt remove [package] 移除 package 程序包\n1 apt [-y] [install | remove | search] [package] -y 自动确认，无需手动确认安装和卸载过程\ninstall 安装\nremove 卸载\nsearch 搜索\npackage 包名\n时间和时区\r1 data [-d] [\u0026#34;+String\u0026#34;] -d 按照指定的字符串显示日期，一般用于日期计算\nString 通过特定的字符串标记，来控制显示的日期形式\n磁盘命令\r1 df [-h] -h 以更人性化的单位显示 查看硬盘的使用情况\n1 iostat [-x] [num1] [num2] -x 显示更多信息\nnum1 数字，表示刷新间隔\nnum2 数字，表示刷新次数\nScreen 命令 - 屏幕\r创建屏幕\r1 screen -S [screen_name] screen_name 要创建的屏幕名称 退出屏幕但不删除当前屏幕\rctrl+A ctrl+D\n1 screen -d -r 恢复屏幕\n-R 尝试恢复屏幕，若恢复失败则创建一个新的屏幕\n-dr 顶掉之前的用户并恢复屏幕\n显示所有屏幕\r1 sreen -ls 检查屏幕，并删除不能使用的屏幕\r1 screen -wipe 删除屏幕\r1 screen [-XS] [-X] [screen_name] quit -XS 在屏幕外删除，需要写屏幕名 -X 删除当前屏幕，不需要写屏幕名 环境变量\r类似于 windows 中的环境变量，Linux 也是使用 PATH 来定义值\n1 export [variable] = [count] variable 变量名\ncount 变量值\n这样可以临时设置一个环境变量\n如果想要永久生效：\n针对当前用户的环境变量： ~/.bashrc 文件中进行修改\n针对所有用户，即系统环境变量： /etc/profile 中的 source 配置文件\n这些修改都是立即生效的\n","date":"2025-03-06T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/126680038_p0.webp","permalink":"https://blog.candquarzy.top/p/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%E9%9B%86%E5%90%88/","title":"Linux指令学习集合"},{"content":"\r基础语法\rC语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。\n二进制语言(101011110) -\u0026gt; 汇编语言(mov eax 10) -\u0026gt; 高级语言(如B语言, C语言等等)\n输出 hello world!\r1 2 3 4 5 6 7 #inculde \u0026lt;stdio.h\u0026gt; //引入头文件 int main() //main函数 { printf(\u0026#34;hello world!\u0026#34;); //printf 基本输出函数 return 0; //返回值 0 } 头文件:C 语言中包含函数声明和宏定义的文件，可被多个源文件中引用共享\nmain 函数:C 语言中最主要的函数，程序的入口，代码从这里依次往下执行\n变量\r1 2 int a = 114514; char str = \u0026#34;hello\u0026#34;; 可以被改变的量，必须先声明后才可以使用\n在函数内申明的变量叫局部变量，局部变量的作用域是局部变量所在的局部范围。出范围就会销毁\n在函数体外声明的变量叫全局变量，全局变量的作用域是程序的生命周期\n若有全局变量和局部变量一样的情况，局部变量的优先级更高\n变量的声明\r1 int i; 数据类型 变量名；\n如果需要在一个源文件中引用另一个源文件中的变量，只需要在要引用的文件中加上 extern 关键字即可\n1 extren int i; 变量的初始化\r1 2 3 int i; //不完全初始化 i = 3; //给变量赋值 int i = 3; //初始化变量 常用基础数据类型\r1 2 3 4 5 6 7 char ch = \u0026#39;a\u0026#39;; short a = 10; int b = 25565; long c = 114514145; long long d = 1145145208910; float e = 3.14; double f = 3.1415926535; char 字符数据类型 1 字节 范围:(有符号:-128 ~ 127/ 无符号 0 ~ 255) short 短整型 2 字节 范围:(-32768 ~ 32767) int 整型 4 字节 范围:(-2147483648 ~ 2147483647) long 长整型 4 字节 范围:(-2147483648 ~ 2147483647) long long 更长的整型 8 字节 float 单精度浮点数 4 字节 范围:(1.2E-38 ~ 3.4E+38) double 双精度浮点数 8 字节 范围:(2.3E-308 ~ 1.7E+308) char 类型也可以通过ACSII码表等价于 int 来使用\n常量\r不能被改变的量被称为常量，分为如下 4 种\n字面常量\nconst 修饰的常变量\n#define 定义的标识符常量\n枚举常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define A 10 //define定义的常量 enum Color //枚举常量 { red; green; blue; }; int main() { 1; //字面常量 const int m = 100; //const修饰的常变量 return 0; } 字符串\r一串字符就是字符串，用双引号括起来\n1 char str[] = \u0026#34;hello world\u0026#34;; \\0 转义字符代表了该字符串的结束(包括strlen()库函数的返回值)，所有定义的字符串最后面都有 \\0，只是被隐藏了\n若一个字符数组内没有加入\\0，则strlen()的返回值为随机值\n基本输出函数 printf()\r1 2 3 4 5 int a = 2; char ch = \u0026#39;a\u0026#39;; double b = 3.14; printf(\u0026#34;%c=%d,圆周率是%lf\u0026#34;, ch, a, b); //输出:a=2,圆周率是3.14 格式: printf(\u0026quot;占位符与内容\u0026quot;, 替换);\n其中占位符会替换后面的变量，常用的占位符有\n%c 读入一个字符\n%d 读入十进制数\n%lld 输入一个长整数\n%o 读入八进制整数\n%x 读入十六进制整数\n%s 读入一个字符串，遇到空格、制表符、或换行符结束\n%lf 读入一个浮点数\n%p 按十六进制读入一个指针 (内存地址)\n%u 读入一个无符号整型\n其中，如果需要保留小数后的位数，可以这样写\n1 printf(\u0026#34;%2lf\u0026#34;, 3.14159265357); //保留小数点后两位 基本输入函数 scanf()\r1 2 int a =0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); //将用户输入的值赋值给变量a 格式: scanf(\u0026quot;占位符\u0026quot;, 变量的地址);\n其中占位符同 printf () 函数\n判断 / 选择语句\r布尔值、真与假\r在 C 语言中，非数字 0 代表条件为真(true)；数字 0 或空(NULL)代表条件为假(false)\nif\r1 2 3 4 5 6 int a = 1; if (a) //if语句 { printf(\u0026#34;%d\u0026#34;, a); } if，即如果，如果 if 后面的 () 内的表达式为真则执行 if 后面的代码\n其格式为:\n1 2 3 4 if (/*表达式*/) { //表达式为真执行的代码 } else\r1 2 3 4 5 6 7 8 9 10 int a = 0; if (a) { printf(\u0026#34;true\u0026#34;); } else { printf(\u0026#34;flase\u0026#34;); } else，与 if 搭配使用。即当 if 中的表达式不满足条件时执行的代码\n其格式为:\n1 2 3 4 5 6 7 8 if (/*表达式*/) { //表达式为真时执行的代码 } else { //不满足表达式的条件时执行的代码 } 悬空 else:else 会与最近的 if 相匹配\nelse if\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 int a = 2; if (a == 1) { printf(\u0026#34;a=1\u0026#34;); } else if (a == 2) { printf(\u0026#34;a=2\u0026#34;); } else { printf(\u0026#34;a=other\u0026#34;); } else if，如果不满足 if 中表达式的条件则尝试匹配 else if 后括号内表达式的内容。在一段判断语句中可有多个 else if\n其格式为:\n1 2 3 4 5 6 7 8 9 10 11 12 if (/*表达式1*/) { //表达式1为真时执行的代码 } else if (/*表达式2*/) { //表达式2为真时执行的代码 } else { //不满足以上所有表达式的条件时执行的代码 } 在代码书写上建议添加大括号，即使执行的代码只有一句。\nswitch\rswitch 语句是一种有限制的控制流语句，它用于根据表达式的值执行不同的代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 char ch; //定义变量ch，但未初始化变量 scanf(\u0026#34;%c\u0026#34;, ch); //将用户输入的值存储在变量ch中 switch (ch) //switch根据ch的值进行判断 { case \u0026#39;a\u0026#39;://若ch的值为字符a //条件成立执行的代码 printf(\u0026#34;input a\u0026#34;); break; //结束判断 case \u0026#39;b\u0026#39;://若ch的值为字符b //条件成立执行的代码 printf(\u0026#34;input b\u0026#34;); break; //结束判断 case \u0026#39;c\u0026#39;://若ch的值为字符c //条件成立执行的代码 printf(\u0026#34;input c\u0026#34;); break; //结束判断 default://若以上条件都不满足 //若以上条件都不满足执行的代码 printf(\u0026#34;input other\u0026#34;); break; //结束判断 } case: 选项标签，若 case 标签后的值符合则执行下面的代码\nbreak (可选): 退出判断，若在单个 case 中没有写 break，将自动往后执行后面的 case 内的语句而不会退出判断\ndefault (可选): 若以上所有 case 条件都不满足执行，相当于默认执行语句\n注意:\ncase 标签后的值必须是一个常量，不能被改变\ncase 标签的顺序并不重要，可以按照任意顺序编写，编译器会从上往下依次匹配\nbreak 不是必须的，只要符合你的运行逻辑就可以了\nswitch() 内的判断变量必须是整型，不能是浮点数\n循环语句\rwhile 循环\rwhile 循环是一种基础的循环，当表达式为 true 则进入循环\n1 2 3 4 5 6 7 8 int a = 0; //初始化变量 while (a \u0026lt;= 5) //当a\u0026lt;=5时进入循环 { //循环体 printf(\u0026#34;%d\u0026#34;, a); a++; } 其格式为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 while (/*表达式*/) { //循环体 if (/*表达式*/) { break; //用于中止循环 } else { continue; //跳过下面的代码，重新开始循环 } //循环体 } break (可选): 结束循环，无论后面还是否有代码，条件是否还满足\ncontinue (可选): 跳过后面的代码，重新开始循环\nfor 循环\r在 for 循环中，将初始化，判断，调整部分作为参数值包含在括号内\n1 2 3 4 for (int i = 0; i \u0026lt;= 10; i++) { printf(\u0026#34;%d\u0026#34;, i); } 其格式为:\n1 2 3 4 for (/*初始化*/; /*判断表达式*/; /*调整部分*/) { //循环体 } break (可选): 结束循环，无论后面还是否有代码，条件是否还满足\ncontinue (可选): 跳过后面的代码，重新开始循环\n循环内部不要重复写循环变量，容易使 for 循环失去控制\n在循环体内改变循环变量的值不可取\n通常使用左闭右开区间的写法\n初始化，判断部分，调整部分均可以省略，这样如果在循环体内没有写退出的判断语句的话，回导致死循环\n且一个 for 循环可以同时初始化 2 个变量\ndo…while 循环\rdo…while 循环与 while 循环最大的区别是 do…while 循环会先执行依次循环体内的代码，然后再进行判断\n1 2 3 4 5 6 7 int a = 0; int count = 0; do count++; printf(\u0026#34;%d\u0026#34;, count); while (a); 其格式为:\n1 2 3 do //循环语句 while (/*判断表达式*/); break (可选): 结束循环，无论后面还是否有代码，条件是否还满足\ncontinue (可选): 跳过后面的代码，重新开始循环\ngoto 语句\r前往一个语句，允许把控制无条件转移到同意函数内的被指定的语句\n不建议使用！容易出现混乱\n最常用的就是跳出多层嵌套循环\n且 goto 语句只能在一个函数范围内跳转，不能跨函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 for(...) { for(...) { for(...) { if(disaster) { goto error; } } } } ... error: if(disaster) { //处理错误情况 } 操作符\r运算符是一种告诉编译器执行特定的数学或逻辑操作的符号\n算数操作符\r+ 加法操作符 对操作符左右两边进行加法运算\n- 减法操作符 对操作符左右两边进行减法运算\n* 乘法操作符 对操作符左右左边进行乘法运算\n/ 除法操作符 将操作符左边的数除以右边 (仅返回整数)\n% 取余运算符 将操作符左边的数除以右边并返回余数 (两端的操作数必须都为整数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 12; int b = 5; printf(\u0026#34;%d\u0026#34;, a + b); //17 printf(\u0026#34;%d\u0026#34;, a - b); //7 printf(\u0026#34;%d\u0026#34;, a * b); //60 printf(\u0026#34;%d\u0026#34;, a / b); //2 printf(\u0026#34;%d\u0026#34;, a % b); //2 printf(\u0026#34;%d\u0026#34;, ++a); //13 printf(\u0026#34;%d\u0026#34;, a--); //13 printf(\u0026#34;%d\u0026#34;, a); //12 return 0; } 如何让 / 运算符输出小数\r一般情况下，/ 运算符得到的商不会是小数，即使是两个 float 类型的数相除也是整数，因此\n1 2 3 4 float a = 6.28; printf(\u0026#34;%2lf\u0026#34;, a / 2); //3 printf(\u0026#34;%2lf\u0026#34;, a / 2.0); //3.14 要让除数 / 被除数是小数\n关系运算符\r== 检查两个操作数是否相等，如果相等条件为真\n!= 检查两个操作数是否相等，如果不相等条件为真\n\u0026gt; 检查操作符左边是否大于右边，如果大于条件为真\n\u0026lt; 检查操作符左边是否小于右边，如果小于条件为真\n\u0026gt;= 检查操作符左边是否大于等于右边，如果大于或等于条件为真\n\u0026lt;= 检查操作符左边是否小于等于右边，如果小于或等于条件为真\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (a == b) { printf(\u0026#34;a=b\u0026#34;); } else if (a \u0026gt; b) { printf(\u0026#34;a\u0026gt;b\u0026#34;); } else { printf(\u0026#34;a\u0026lt;b\u0026#34;); } //执行结果为 a\u0026gt;b 逻辑运算符\r\u0026amp;\u0026amp; 逻辑与运算符，如果左右两个表达式都为真，则表达式为真\n|| 逻辑或运算符，如果左右两个表达式有一个为真，则表达式为真\n! 取反 (逻辑非)运算符，逆转后面表达式的逻辑状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int a = 10; int b = 0; if (a \u0026amp;\u0026amp; b) { printf(\u0026#34;a\u0026amp;\u0026amp;b为true\\n\u0026#34;); } if (a || b) { printf(\u0026#34;a||b有一个为true\\n\u0026#34;); } if ( !b ) { printf(\u0026#34;b为flase\\n\u0026#34;); } //执行结果为 //a||b有一个为true //b为flase 对于 \u0026amp;\u0026amp; 操作符来说，如果第一个表达式为假，后面的表达式不会进行计算\n对于||操作符来说，如果第一个表达式为真，后面的表达式都不会进行计算\n赋值操作符\r= 赋值操作符，将操作符右边的数赋值给左边\n+= 加等运算符，将操作符右边的数累加给左边\n-= 减等运算符，将操作符左边的数减去右边并赋值给操作符左边的变量\n*= 乘等运算符，将操作符右边的数乘给左边\n/= 除等运算符，将操作符左边的数除以右边并将结果赋值给左边\n%= 模等运算符，将操作符左边的数除以右边得到余数后赋值给左边\n++ 自增运算符 将整数值增加 1\n–- 自减运算符 将整数值减少 1\n1 2 3 4 5 6 7 8 int a = 10; int b = 20; a += b; printf(\u0026#34;%d\u0026#34;, a); //30 a -= b; printf(\u0026#34;%d\u0026#34;, a); //10 自增 / 自减中前置与后置的区别\r前置 ++:先自增后使用\n1 2 3 int a = 10; printf(\u0026#34;%d\u0026#34;, ++a) //11 后置 ++:先使用再自增\n1 2 3 int a = 10; printf(\u0026#34;%d\u0026#34;, a++); //10 请不要过分追求 ++ 和 -- 等运算符的结果 因为没有意义且不同编译器结果可能不同\n1 2 3 4 5 6 7 8 9 int main() { int a = 1; int b = (++a) + (++a) + (++a); printf(\u0026#34;%d\\n\u0026#34;, b); return 0 } 上面这段代码在MSVC编辑器运行的结果为12，而在Linux系统gcc编译器运行的结果为10\n\u0026laquo;= 左移并赋值运算符\n\u0026gt;\u0026gt;= 右移并赋值运算符\n\u0026amp;= 按位与并赋值运算符\n^= 按位异或并赋值运算符\n|= 按位或并赋值运算符\n位运算符\r\u0026amp; 按位与运算符:按二进制位，如果相同为 1，不同为 0\n| 按位或运算符:按二进制位，如果有 1 则为 1，如果没有 1 则为 0\n^ 按位异或运算符:按对应的二进制位进行异或，相同位 0，相异为 1\n\u0026lt;\u0026lt; 左移运算符，将左边丢弃，右边补 0\n\u0026gt;\u0026gt; 右移运算符，①算术右移:右边丢弃，左边补原符号位；②逻辑右移:右边丢弃，左边补 0\n位操作符所运算的数字必须是整数\n所有位操作符所操作的对象都为二进制位\n原码 直接写出来的二进制数 反码 原码的所有位按位取反 补码 反码 + 1 移码 补码的基础上将符号位按位取反(仅能表示整数) 单目操作符\r只有一个操作数的情况下叫做单目操作符\n+ 正号\n- 负号\nsizeof 计算和统计操作符的类型变量等所占用内存空间的大小，结果为 unsigned int 类型 (不是函数! 是操作数符!)\n~ 对一个数的二进制位进行按位取反，原来的 1 变成 0，原来的 0 变成 1。包括符号位\n\u0026amp; 取地址操作符，取出该变量的地址\n* 解引用操作符 / 指针变量类型 / 间接访问操作符\n(类型) 强制类型转换操作符\n1 2 3 4 int a = 10; int* pa = \u0026amp;a; pirntf(\u0026#34;%d\u0026#34;, *pa); //10 sizof 括号中存入的表达式是不参与运算的，并且会返回第一个读取到的变量值\n因为 sizeof 是在编译阶段进行处理的，而表达式是在运行阶段才执行的\n其他操作符\rexp1?exp2:exp3 三目操作符:exp1 是否满足？满足执行 exp2，不满足执行 exp3\n, 逗号表达式，重做向右依次执行，结果位最后一个表达式的结果\n[] 下标引用操作符\n() 函数调用操作符\n. 结构体成员访问操作符 (变量)\n-\u0026gt; 结构体成员访问操作符 (指针)\n1 2 3 4 5 6 7 int a = 0; int b = 3; int c = 5; int d = (a = b + 2, c= a - 4, b = c + 2); // a=5 c=1 b=3 d=b=3 printf(\u0026#34;%d\u0026#34;, d); [] 操作符的操作数有两个，一个是数组名，一个是下标准\n操作符优先级\r类别 运算符 结合性 后缀 () [] -\u0026gt; . ++ – 从左到右 一元 + - ! ~ ++ – (tpye)* \u0026amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 \u0026laquo; \u0026raquo; 从左到右 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 相等 == != 从左到右 位与 and \u0026amp; 从左到右 位异或 ^ 从左到右 位或 | 从左到右 逻辑与 and \u0026amp;\u0026amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += - += *= /= %= \u0026raquo;= \u0026laquo;= \u0026amp;= ^= |= 从右到左 逗号 , 从左到右 关键字\r函数 / 变量名不能是关键字\n以下为部分常见关键字:\nauto 每个局部变量都是由 auto 修饰的 比如 auto int a = 10 只不过默认省略\nconst 常变量 将一个变量修饰为常变量(严格来说不算常量)\nextern 用于声明外部符号(如变量、函数等)\nregister 寄存器关键字 用于建议编译器将此变量存储在寄存器中\nsigned 有符号的\nunsigned 无符号的\nstatic 静态的 改变生命周期(本质上是改变了变量的存储类型) 只能在自己所在的源文件中使用\ntypedef 类型重命名 可以将一个类型重命名另一个关键字 如 typedef unsigned int u_int\nvolatile ?\n请注意 define 和 include 不是关键字，而是预处理指令\n函数\r函数分为库函数和自定义函数两种，库函数为 C 编译器编译的函数如:\nIO函数 printf() scnaf() getchar() putchar()\n字符串操作函数 strcmp() strlen()\n字符操作函数 toupper()\n内存操作函数 memcpy() memcmp() memset()\n时间日期函数 time()\n数学函数 sqrt() pow()\n其他…\n学习库函数两个网站:cplusplus(英文)，cppreference (中文)\n定义函数\r自定义函数即自己定义的函数，是一组一起执行一个任务的语句块。而每个 C 程序都必须要有一根函数，即主函数 main ()\n一个函数内不可定义另一个函数，但函数内部可以相互调用，也可以自己调用自己 (函数递归)\n函数的自定义格式如下\n1 2 3 4 ret_type fun_name (para1, *) { statement; } ret_type 函数的返回值类型\nfun_name 函数名\npara1, * 函数形参\nstatement 函数体\n例:一个加法函数\n1 2 3 4 int Add (int x, int y) { return x+y; } 函数的返回类型 一个函数可以返回一个值，ret_type 是函数返回值的数据类型。有些函数可能并不需要返回值，在这种情况下，可以写关键词 void\n函数名 函数的名称，你可以给函数起一个让人一看就可以看懂这个函数的作用的名字\n函数形参 函数的形式参数，当函数被调用时，你可以将一个实参传入该函数的形参，然后在该函数内使用该参数。函数的形参是可选的，也就是说，创建一个函数可以没有形参\n函数体 函数主体内的一系列要执行任务的语句\n若一个函数不写返回类型的话，默认返回int\n函数的参数不宜过多\n函数的设计应该追求高内聚低耦合\n设计函数时，应做到谁申请的资源由谁释放\n调用函数\r调用函数使用函数调用操作符()\n1 fun(para1, …); fun 函数名\n() 函数调用操作符\npara1 传给函数的实参\n函数参数\r实参与形参\r实际参数 又称实参 真实传给函数的参数。实参可以是:常量、变量、表达式、函数等。无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参\n形式参数 又称形参 形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化 (分配内存单元)，所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。\n传值调用\r实参 即为实际的参数，有值。通常用于将值传递给形参\n形参 形式参数，在 C 中无值，用于接收实参传递过来的值\n例如，在这个例子中，实参 a 将值传递给形 x，实参 b 将值传递给 y。函数将 x 和 y 的值相加后后返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 int Add (int x, int y) { return x+y; } int main () { int a = 5; int b = 8; printf(\u0026#34;%d\u0026#34;, Add(a, b)); return 0; } 在这个案例中，函数的形参和实参分别占有不同的内存，对形参的修改不会影响实参，也就是说，形参只是形参的一份临时拷贝。实参中的值并未发生改变\n传址调用\r那如果我想要改变形参中的值呢？这个时候就要将形参的内存地址传递给函数形参 (详见 “指针”)，这种方式可以使函数和函数外边的变量建立起真正的练习，也就是说可以通过指针操作函数外部的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Add (int* x, int* y) { *x = 50; *y = 80; return *x+*y; } int main () { int a = 5; int b = 8; printf(\u0026#34;%d\\n\u0026#34;, Add(\u0026amp;a, \u0026amp;b)); //130 printf(\u0026#34;%d %d\u0026#34;, a, b); //50 80 return 0; } 如上案例，将实参 a 和 b 的地址分别传入形参 x 和 y 中，并修改 x 和 y 的值，由于 x 和 y 所存储的是变量 a 和 b 的地址，所以在函数内部对 x 和 y 做更改实际上会更改 a 和 b 的值\n数组传参\r数组传参，实际传递的并不是数组本身，而是将数组首元素的地址传了过去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void fun (int arr[], int sz) { for (int i = 0; i \u0026lt;= sz; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } int main () { int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int sz = sizeof(arr) / 4 - 1; fun(arr, sz); return 0; } 务必在函数体外计算数组元素个数，在函数内部是无法得知数组元素个数的\n数组传参可以使用 int* 和 int arr[] 来接收。本质都是指针\n详细解释见 “数组” 一章\n函数声明\r由于编译器是一行一行顺序编译代码，如果你的函数体在函数调用之后，那么编译器是找不到要执行的代码的，因此会报错\n我们可以在调用这个函数前先对函数进行声明\n函数需要满足先声明后使用\n1 int Add (int, int); 声明需要函数名，函数参数，返回类型。但是该函数具体存不存在无所谓\n通常会将函数的声明放在头文件中，然后再在.c 文件中引用\n模块化函数\r可以将函数分开来写，然后在通过头文件引入\n通常需要一个.h 文件和一个.c 文件。将函数声明放在.h 文件中，函数体放在.c 文件中，然后在要使用该函数的.c 文件中引用.h 头文件\n例如，main.c 要使用由 add.h 声明的 add.c 文件中的 add () 函数，那可以这样写\n1 int Add (int x, int y); 1 2 3 4 int Add (int x, int y) { return x+y; } 1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;add.h\u0026#34; int main () { printf(\u0026#34;%d\u0026#34;, Add(5, 8)); return 0; } 要将这些文件放在可以调用到的路径下\n递归\r一个过程或函数在其定义或说明中直接或间接调用自己的方式就叫做递归。可以简单理解为自己调用自己 (我搞懂了，但我依然不会写)\n递归只需要少量的代码即可完成之前所需要的多次重复计算\n在函数调用自己的时候，后面的代码不会执行。只有等函数执行完之后才会继续执行下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Print(unsigned int n) { if (n / 10) { Print(n / 10); } printf(\u0026#34;%d \u0026#34;, n % 10); } int main() { int a = 12345; Print(a); return 0; } 如上代码是一个将一个整数按每一位的顺序输出的代码，其输出结果为 1 2 3 4 5\n以下是原理讲解\n将 a 传入 Print 函数的形参 n，n 的值现在为 12345\n调用函数，第一次判断 n/10\u0026gt;0，条件为真，进入 将 n/10，即 1234 传给 Print 函数的形参 n\n调用函数，第二次判断 n/10\u0026gt;0，条件为真，进入 将 n/10，即 123 传给 Print 函数的形参 n\n调用函数，第三次判断 n/10\u0026gt;0，条件为真，进入 将 n/10，即 12 传给 Print 函数的形参 n\n调用函数，第四次判断 n/10\u0026gt;0，条件为真，进入 将 n/10，即 1 传给 Print 函数的形参 n\n调用函数，第五次判断 n/10\u0026gt;0，条件为假，继续执行下面的代码\n此时 n%10 为 1，printf 语句即输出 1\n到此，Print 函数一共被调用了 5 次，但是目前只有第五次完完全全执行完了函数体，所以，现在开始返回执行\n返回，执行第 4 次调用函数后的 printf 语句，输出 2\n返回，执行第 3 次调用函数后的 printf 语句，输出 3\n返回，执行第 2 次调用函数后的 printf 语句，输出 4\n返回，执行第 1 次调用函数后的 printf 语句，输出 5\n此时，函数运行结束\n因此递归有两条重要条件\n要存在限制条件\n每次递归必须越来越接近这个限制条件\n这俩是必要条件，如果没有，一定会导致死循环\n在 C 中，每一个函数调用都会占用栈区的空间，每调用一次就会多占用一次。调用太多次函数就会导致栈溢出的问题。因此递归调用层次不能太深\n数组\r数组就是一种相同类型元素的集合\n一维数组\r声明数组\r1 type_t arr_name[const_n]; type_t 元素的数据类型\narr_name 数组的名称\nconst_n(可为空) 数组的大小，为常量表达式。若为空编译器会根据后面存储内容的个数来确定数组的大小\n1 int arr[10]; 数组的初始化\r1 2 int arr[10] = {1, 2}; //不完全初始化 int arr[2] = {1, 2,}; //完全初始化 数组的元素通常使用 {存储数字型}，“存储字符串”，{‘存储字符’} 等符号来存储元素\n1 2 3 int arr[10] = {1, 2, 3, 4, 5}; //存储数字型 char ch[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; //存储字符 char str[] = \u0026#34;hello world!\u0026#34;; //存储字符串，结尾有隐藏的\u0026#39;\\0\u0026#39; 数组的使用与更改\r数组使用 [] 下标引用操作符来获取数组中的元素\n请注意！数组中的元素从 0 开始排列，也就是说，数组的第一个元素下标为 0，依次类推\n可以使用数组名 [下标] 的方式为数组中的元素重新赋值\n1 2 3 4 int arr[10] = {1, 2, ,3, 4, 5, 6, 7, 8, 9}; printf(\u0026#34;%d\u0026#34;, arr[0]); //1 arr[0] = 0; printf(\u0026#34;%d\u0026#34;, arr[0]); //0 数组与内存\r数组名是数组首元素的地址，每个元素都是挨着存储的，随着数组下标的增长，地址是由低到高变化的\n二维数组\r声明二维数组\r1 type_t arr_name [const_n1] [const_n2]; type_t 元素的数据类型\narr_name 数组的名称\nconst_n1 数组的行数 (可以省略)\nconst_n2 数组的列数 (不可省略)\n1 int arr[2][3]; //数组为2行3列，总共可容纳6个元素 二维数组的行号可以省略不写，但是列必须写！\n二维数组的初始化\r1 2 int arr[][3] = {1}; //不完全初始化 int arr[2][3] = {{1, 2},{3, 4},{5, 6}}; //完全初始化 二维数组的使用与更改\r二维数组同一位数组一样，都是使用 [] 下标引用操作符来操作数组中的元素，二维数组中的元素行和列都是从 0 开始排列的\n1 2 3 int arr[2][3] = {{1, 2},{3, 4},{5, 6}}; printf(\u0026#34;%d\u0026#34;, arr[0][0]); //1 printf(\u0026#34;%d\u0026#34;, (arr[1])[1]); //4 二维数组的每行都可以看作一维数组数组名即为数组名[行号]\n二维数组在内存中的存储\r每个元素的位置是连续的，在一行内部连续，换行也是连续的。二维数组的首元素是第一行\n二维数组与一维数组\r二维数组每一行可以单独拆分称为一个一维数组\n1 2 int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; int (*p)[2] = arr; 在这里，p 是第一行数组的地址，p+1 就是第二行数组的地址\n数组作为函数参数\r数组传参本质上传过去的是数组首元素的地址，是一个指针。即数组名就是数组首元素的地址\n详细解释见 “指针” 一章\n1 2 type_t fun_name (type_t arr_name[]); type_t fun_name (type_t* arr_name); type_t 数据类型\nfun_name 函数名\narr_name[] 数组形参，接收数组首元素地址\narr_name 数组名，接收数组首元素地址 (即数组名)\n但是有两个例外\nsizeof (数组名) 这里的数组名代表的是整个数组，计算整个数组的大小，单位是字节 \u0026amp;数组名 数组名表示整个数组，取出的是整个数组的地址，而数组首元素的地址相当于数组的起始地址 假设都要 + 1，\u0026amp;arr 会跳过这个数组，而 arr 只会跳过这个数组中的第一个元素\n传参传过去的数组在函数体内部是无法计算其元素个数的\n指针\r每一个变量都有其内存位置，每个内存位置都定义了一个可以使用 \u0026amp; 运算符访问的地址。它表示了其变量在内存中的地址 (为第一个字节的地址)\n指针其实也就是内存地址，指针变量就是用来存放内存地址的变量\n32位计算机表示32根地址线，即32个bit位\n64位计算机表示64根地址线，即64个bit位\n指针变量\r1 2 int a = 10; int* pa = \u0026amp;a; //取出a的地址，放入指针变量pa中 * 表示是指针变量\nint 说明指向的变量类型是 int\n在这里，pa 是指针变量。*pa 等于对指针变量 pa 进行解引用，这样就可以获取到值 (也就是那个 10)\n解引用操作\r通过指针变量的地址改变原本存在的变量\n1 2 3 4 5 int a = 10; int* pa = \u0026amp;a; *pa = 20; printf(\u0026#34;%d\u0026#34;, a); //20 在这里，指针变量 pa 存入 int 型变量 a 的地址，也就是说 pa 指向的是 a 的地址\n那么 *pa 就是对 pa 进行解引用操作，可以获取到 a 这块内存地址中的值，故可以改变 a 变量的值\n指针变量的大小\r在 32 位计算机上是 4 个字节\n在 64 位计算机上是 8 个字节\n指针变量类型的两个意义:\n指针解引用的权限有多大 指针的步长 (如 int 为 4，char 为 1，double 为 8) void* 是一种无具体类型的指针，所以任何类型的地址都可以丢进去 注: void*类型的指针无法解引用!\n这里的权限与步长指的是该指针变量可以操作内存的bit位数\n野指针\r野指针就是指针指向的位置是不可知的指针\n指针未初始化\r1 2 3 4 5 6 7 int main() { int* p; //指针变量p是一个未初始化的局部变量，不初始化的话默认是随机值 *p = 20; //非法访问内存 return 0; } 越界访问\r1 2 3 4 5 6 7 8 int arr[10] = {0}; int* p = arr; for(int i = 0; i \u0026lt;= 10; i++) { *p = i; p++; } 在上面这个例子中，i 会等于 10。然后在循环中 i 会从 0 循环到 10。但是数组的元素个数是 10 个，下标却最高到 9。解析到 10 的时候就会导致指针越界访问\n指针指向的空间被释放\r1 2 3 4 5 6 7 8 9 10 11 12 13 int* test() { int a = 10; return \u0026amp;a; } int main() { int* p = test(); *p = 20; return 0; } 在上面的这个例子中，函数执行结束后该函数所占用的内存会被释放 (归还给操作系统)。因此 *p 实际上指向的内存地址其实是越界访问。然后解引用将 20 赋值给指针变量 p，自然会出问题\n如何避免野指针？\r指针初始化:当不知道指针应该初始化为什么的时候，就初始化为 NULL 吧！准没错\n小心指针访问越界\n指针指向空间释放后及时置空 (指向 NULL)\n指针使用之前检查其有效性 (不要访问空指针，空指针无法访问)\n当知道指针指向哪里的时候，指向一个地址\n当不知道指针指向哪里的时候，置为空指针\n当指针空间被释放的时候，也可以置为空指针\n每次使用指针变量的时候，可以先 if 判断一下指针变量是否为空\n指针运算\r指针++ 和 指针-- (移动指针)\n指针 - 指针 得到两个指针之间的元素个数\n指针的关系运算 (如比较指针所在的位置)\n1 2 3 *p++; *p[9] - *p[0] *p \u0026lt; \u0026amp;arr[0] 指针和指针相减的前提是两个指针指向同一块空间\n标准规定:允许指向数组元素与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较\n指针+指针是没有意义的。类比如日期加日期\n指针与数组\r数组名是数组首元素的地址\n1 2 3 4 int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int*p = arr; //则有:arr[2] == *(arr+2) == *(p+2) == *(2+p) == *(2+arr) == 2[arr] == *(2+arr) 上文中注释的原理:因为代码为 arr[2] 时，编译器会处理为 *(arr+2) 也就等价于 *(2+arr) 等价于 2[arr]\n二级指针\r1 2 3 4 5 6 7 8 9 int main () { int a = 10; int* pa = \u0026amp;a; //pa是一级指针变量 int** ppa = \u0026amp;pa; //pa也是给变量，取出pa的内存地址放入二级指针变量ppa中 return 0; } *ppa == pa; *pa == a;\n**ppa == a;\n二级指针在实际开发中不常用，当然也可以有三级指针，四级指针\n指针数组\r接下来要开始乱了，做好心理准备\n存放整型的数组就是整型数组\n存放字符的数组就是字符数组\n存放指针的数组就是指针数组\n1 2 3 4 5 int a[] = {1, 2, 3, 4, 5}; int b[] = {2, 3, 4, 5, 6}; int c[] = {3, 4, 5, 6, 7}; int* arr[3] = {a, b ,c}; //指针数组 字符指针\r1 2 3 4 char* s = \u0026#39;a\u0026#39;; char * 本质上是将字符串的首字符地址存储起来了 char * 是常量字符串，通常会写成 const chart* s = \u0026#39;a\u0026#39;; 指针是可以指向一个字符串的，指向的字符串的首元素所在的地址\n数组指针\r数组指针就是一种指向数组的指针\n1 int arr[] = {0}; arr 是数组首元素的地址\n\u0026amp;arr 才是数组的地址\n1 int (*parr)[10] = \u0026amp;arr; * 要和 parr 结合，表示是数组指针。类型是 int\n[] 内的元素个数一定要写，并且只能写原数组的元素个数\n1 2 3 4 int arr[5]; //整型数组 int* parr1[10]; //整型指针的数组 int (*parr2)[10]; //数组指针，指向一个数组，数组10个元素每个元素类型是int int(*parr3[10])[5]; //存放数组指针的数组，存放10个数组指针，每个数组指针指向一个数组，数组5个元素。类型是int 函数指针\r指向函数的指针，存放函数地址的指针\n\u0026amp;函数名 可以得到函数的地址\n函数名也就是函数的地址\n因此 函数名 == \u0026amp; 函数名\n函数指针变量\r1 2 3 4 5 6 7 8 int Add(int x, int y) { return x + y; } int(*pf)(int, int) = Add; (*pf)(3, 5); //使用函数指针传参 在这里 (*pf) == pf == Add == \u0026amp;Add 因为函数名就是函数的地址\n来两道练习题吧 (\n请解释下面代码是什么意思\n1 (*(void(*) ())0) (); 请解释下面代码是什么意思\n1 void (* singnal (int, void(*) (int)) ) (int); 函数指针数组\r指存放函数指针的数组\n1 int (*pfArr[5]) (int, int) = {NULL, Add, Sub, Mul, Div}; 指向函数指针数组的指针\r取出函数指针数组的地址\n1 2 3 int (*p)(int, int); //函数指针 int (*p2[4])(int, int); //函数指针的数组 int (*(*p3)[4])(int, int) = \u0026amp;p2; //取出的是函数指针数组的地址 在这里，p3 就是一个指向函数指针数组的指针\n回调函数\r通过函数指针调用的函数，如果你把函数的指针作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就是回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Add(int x, int y) { return x + y; } int Calc(int (*pf)(int, int)) { int x = 0; int y = 0 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); return pf(x, y); } int ret = Calc(Add); printf(\u0026#34;ret = %d\\n\u0026#34;, ret); 结构体\r结构体是一些值的集合，但是值的类型可以不同\n1 2 3 4 5 struct Person { char name[]; //我也忘记是不是这样写的了 C++谁用char[]类型 int age; }p1; Person 结构体标签，也就是这个结构体的名称\n{}; 大括号内为结构体成员，请务必注意要在右括号后面加；\n结构体成员 可以是变量，数组，指针，甚至是其他结构体\np1 结构体全局变量\n结构体的初始化\r1 2 3 4 5 6 7 8 9 10 struct Book { char name[20]; int price; char id[12]; }b4,b5,b6; struct Book b1; struct Book b2; struct Book b3; 在这里 b1,b2,b3 为局部变量，而 b4,b5,b6 为全局变量\n1 2 3 4 5 6 7 8 9 10 11 struct S { char c; int i; }; int main() { struct S s3 = {\u0026#39;A\u0026#39;, 20}; return 0; } struct 结构体标签 对象 = {值};\n匿名结构体类型\r1 2 3 4 5 6 7 struct { char c; int i; char ch; double d; }; 匿名结构体类型，只能使用一次，有局限性\n结构体的自引用\r1 2 3 4 5 6 7 8 9 10 11 12 struct A { int i; char c; }; struct B { char c; struct A sa; double d; }; 一个结构体内可以包含另一个结构体的成员，但是不可以包含结构体自己的成员，会导致死递归\n但是可以存自己的结构体指针\n1 2 3 4 5 struct Node { int data; struct Node* next; }; 表示这个节点可以找到同类型的下一个节点就叫做结构体自引用 对的 就是链表\n结构体成员的访问\r. 用于变量\n-\u0026gt; 用于地址\n1 2 3 4 5 tag.name tag.tage2.id struct tag* ps = \u0026amp;a; ps-\u0026gt;name; 结构体传参\r1 2 function_name(struct tag s); //传结构体 function_name(struct tag* pa); //传地址 传址调用更好，效率高。能够改变变量的数值。同时，函数传参时，参数是需要压栈的，结构体如果过大会导致系统开销比较大，这将会导致性能的下降\n结构体内存对齐\r首先，掌握结构体的对齐规则\n第一个成员在与结构体变量偏移量为 0 的地址处\n其他成员变量要对齐到某个数字 (对齐数)的整数倍的地址处\n结构体总大小为最大对齐数 (每个成员变量都有一个对齐数)的整数倍\n如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数 (含嵌套结构体的对齐数)的整数倍\n对齐数 编译器默认的一个对齐数与该成员大小的较小值 (VS 中的默认对齐数为 8)\n为什么会存在内存对齐？\n平台原因 不是所有的硬件平台都能访问任意地址上的任意数据的 某些硬件平台只能\u2029在某些地址处取某些特定类型的数据，否则抛出硬件异常 性能原因 数据结构(尤其是栈)应该尽可能地在自然边界上对齐 为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问 总体来说，结构体内存对齐是拿空间换时间的做法\n可以使用 #pragma pack(8) 来修改默认对齐数 比如这里设定为8\n* 柔性数组\r在 C99 中，结构体的最后一个元素允许是未知大小的数组，这就是柔性数组成员\n柔性数组的声明\r1 2 3 4 5 6 7 8 9 10 11 struct S { int n; int arr[0]; //大小是未知 }; struct S { int n; int arr[]; }; 两种写法都可以，具体取决于编译器\n结构体中的柔性数组成员前面必须只有有一个其他成员\nsizeof 返回的这种结构的大小不包括柔性数组的内存大小\n包含柔性数组成员的结构使用 malloc () 函数进行内存的动态分配，并且分配的内存应当但与结构体的大小，以适应柔性数组的预期大小\n柔性数组的使用方式\r1 2 3 4 5 6 7 8 9 10 11 struct S { int n; int arr[0]; }; int main() { //期望arr的大小是10个int struct S *ps = (struct S*)malloc(sizeof(struct S) + 10 * sizeof(int)); } 柔性数组的优点\r方便内存释放 如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用 free 可以释放结构体，但是用户并不知道这个结构体内的成员也需要 free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次 free 就可以把所有的内存也给释放掉。 这样有利于访问速度 连续的内存有益于提高访问速度，也有益于减少内存碎片。~~ (其实，我个人觉得也没多高，反正你跑不了要用做偏移量的加法来寻址~~\n位段\r位段的声明\r位段的声明和结构体是类似的，只是有两个不同\n位段的成员必须是 int. unsigned int 或 signed int\n位段的成员名后面有一个冒号和一个数字\n位段的成员也可以 char 类型，因为 char 属于整型家族\n1 2 3 4 5 6 7 struct A { int _a :2; //_a成员占用2个bit位 int _b :5; //_b成员占用5个bit位 int _c :10; //_c成员占用10个bit位 int _d :30; //_d成员占用30个bit位 }; 位段的空间是按照需要以 4 个字节 (int) 或者是 1 个字节 (char) 的方式来开辟的\n位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应当避免使用位段\n位段的跨平台问题\rint 位段被当成有符号数还是无符号数是不确定的\n位段中的最大位的数目不能确定 (16 位机器最大 16，32 位机器最大 32。例如写成 27，在 16 位机器上就会出现问题)\n位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义\n当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，是舍弃剩余的位还是利用，这也是不确定的\n总结:跟结构体相比，位段可以达到同样的效果，并且可以更好的节省空间。不过会有跨平台的问题存在\n枚举\r枚举的意思就是一一列举，把可能的类型一一列举\n枚举的声明\r1 2 3 4 5 6 enum Color { RED, GREEN, BLUE }; enum 声明枚举的关键字\nColor 枚举名\n{}; 枚举的类型，值为常量\n枚举类型的值默认从 0 开始，每往后自增 1\n为什么使用枚举？\r虽然我们可以使用 #define 定义常量，为什么非要使用枚举？枚举的优点:\n增加代码的可读性和可维护性\n和 #define 定义的标识符比较，枚举有类型检查，更加严谨\n防止了命名污染 (封装)\n便于调试\n使用方便，一次性即可定义多个常量\n联合(共用)体\r联合体也叫共用体，其中的成员共用一块内存空间。这个联合体的大小，至少是最大成员的大小\n联合体的声明\r1 2 3 4 5 6 union Un { char c; int i; float f; }; 联合体的初始化\r1 union Un u = {10}; 联合体在同一时间只能使用一个\n联合体的大小\r联合体也是存在内存对齐的\n联合体的大小至少是最大成员的成员的大小\n当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍\n* 数据存储\r该内容为计算机组成原理，了解即可\n栈区使用习惯\r先使用高地址，再使用低地址\nchar 并没有规定有无符号，因此其判断取决于编译器\n整型数据的存储\r正整数 原码，反码，补码相同 负整数 原码，反码，补码需要进行计算 原码 根据数字的值直接写出的值就是原码 (比如 1 的原码 00000000 00000000 00000000 00000001)\n反码 原码的符号位不变，其他位按位取反 (比如 1 的反码 01111111 11111111 11111111 11111110)\n补码 在反码的基础上 + 1 即为补码 (比如 1 的补码 01111111 11111111 11111111 11111111)\n整数在内存中存储的都是补码\n大小端字节序\r大端字节序 把数据的低位字节序内容存储在高地址处，高位字节序的内容存储在低地址处 小端字节序 把数据的低位字节序内容存储在低地址处，高位字节序的内容存储在高地址处\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //通过代码来判断当前机器的字节序 int a = 1; char* p = (char*)\u0026amp;a; if(*p == 1) { printf(\u0026#34;小端\\n\u0026#34;); } else { printf(\u0026#34;大端\\n\u0026#34;); } return 0; } 浮点型数据的存储\r浮点数的存储由 IEEE 754 规定\n(-1) ^S * M *2^E\n(-1)^S 表示符号位 当 S=0，V 为正数，当 S=1，V 为负数\nM 表示有效数字 大于等于 1，小于 2\n2^E 表示指数位\n字符串相关库函数\rC++ string 容器启动！\n首先需要包含头文件 \u0026lt;string.h\u0026gt;\nstrlen () 字符串计数函数\r1 size_t strlen(const char* str); 字符串使用\\0作为结束标志，而 strlen 函数返回的就是在字符串中遇到’\\0’之前所出现的字符的个数(不包括 \\0)\n也因此，传入 strlen() 的函数参数必须以\\0结束\n同时，strlen() 的返回值为 size_t，是无符号的\n由于 strlen 返回的是无符号整数，因此该函数的返回值相间会进行整型提升\nstrcpy () 字符串复制函数\r1 char* strcpy(char* destination, const char* source); destination 要复制到的字符串(目标字符串)\nsource 被复制的字符串(原字符串)\n源字符串必须以’\\0‘结束 会将源字符串中的’’\\0’拷贝到目标空间 目标空间必须足够大，以确保能存放源字符串 目标空间必须可变 strcat () 字符串追加函数\r1 char* strcpy(char* destination, const char* source); destination 要复制到的字符串\nsource 被追加的字符串\n源字符串必须以’\\0’结束 目标空间必须有足够大，能容纳下源字符串的内容 目标空间必须可修改 字符串不能自己给自己追加 会把目标空间的’\\0’覆盖掉 返回的是目标空间首字符的地址 strcmp () 字符串比较函数\r1 int strcmp(const char* str1, const char* str2); 通过ACSII码表的值进行比较\n返回值 \u0026lt;0 str1 比 str2 小\n返回值为 0 str1 和 str2 相等\n返回值 \u0026gt;0 str1 比 str2 大\nstrncpy () 字符串拷贝函数 (长度受限)\r1 char* strncpy(char* destination, const char* sourse, size_t num); destination 要拷贝到的的字符串\nsourse 被拷贝的字符串\nnum 要拷贝 sourse 字符串的多少个字符\n若拷贝的字符数量大于要拷贝的字符串的长度，会全部替换为\\0，且原字符串后面的字符不变\nstrncat () 字符串追加函数 (长度受限)\r1 char* strncat(char* destination, const char* sourse, size_t num); destination 要追加到的的字符串\nsourse 被追加的字符串\nnum 追加 sourse 字符串的多少个字符\nstrncmp () 字符串比较函数 (长度受限)\r1 int strncmp(char* str1, counst char* str2, size_t num); str1 str2 要被比较的两个字符串\nnum 比较多少个字符\n会比较到出现另一个不一样的字符或者字符串结束或者num个字符全部比较完\nstrstr () 字符串查找函数\r1 char* strstr(const char* str1,const char* str2); 在 str1 中查找 str2 是否存在 找到了返回第一个字符在被查找的字符串中的位置，找不到返回 NULL\nstrtok () 字符串切割函数\r1 char* strtok(char* str, const char* sep); str 要被切割的字符串\nsep 定义了用作分隔符的字符的集合\n第一个参数指定一个字符串，它包含了 0 个或者多个由 sep 字符串中一个或者多个分隔符分割的标记 strtok 函数找到 str 中的下一个标记，并将其用’\\0’结尾，返回一个指向这个标记的指针 (注:strtok 函数会改 变被操作的字符串，所以在使用 strtok 函数切分的字符串一般都是临时拷贝的内容并且可修改) strtok 函数的第一个参数不为 NULL，函数将找到 str 中第一个标记，strtok 函数将保存它在字符串中的位置 strtok 函数的第一个参数为 NULL，函数将在同一个字符串中被保存的位置开始，查找下一个标记；如果字符串中不存在更多的标记，则返回 NULL 指针。 strerror 错误码解析函数\r1 char* strerror(int errnum); errnum返回的错误码 错误码 strerror 函数处理后内容 0 No error 1 Operation not permitted 2 No such file or directory 3 No such process 4 Interrupted function call 5 Input/output error 字符相关库函数\r首先需要包含头文件 \u0026ldquo;ctype.h\u0026rdquo;\nC++ 就变成 cctype 抽象死了\n函数 如果其参数符合下列条件就返回真 iscntrl 任何控制字符 isspace 空白字符:空格’ ’ 换页’\\f’ 换行’\\n’ 回车’\\r’ 制表符’\\t’ 垂直制表符’\\v’ isdigit 十进制数字 0-9 isxdigit 十六进制数字，包括所有十进制数字，小写字母 a-f，大写字母 A-F islower 小写字母 a-z isupper 大写字母 A-Z isalpha 字母 a-z 或 A-Z isalnum 字母或者数字，a-z，A-Z，0-9 ispunct 标点符号，任何不属于数字或者字母的图形字符 (可打印) isgraph 任何图形字符 isprint 任何可打印字符，包括图形字符和空白字符 tolower 将字符转换为小写 toupper 将字符转换为大写 内存相关库函数\rmemcpy() 内存拷贝函数\r该函数应当拷贝不重叠的内存，如果内存重叠就需要使用 memmove() (在 VS 编译器中虽然可以拷贝过去，但是并非标准所规定，建议优先使用 memmove())\n1 void* memcpy (void* destination, const void* source, size_t num); destination 目标内存\nsource 被拷贝的内存\nnum 拷贝多少 单位:字节\nmemmove() 内存拷贝函数\r1 void* memmove (void* destination, const void* source, size_t num); destination 目标内存\nsource 被拷贝的内存\nnum 拷贝多少 单位:字节\nmemcmp() 内存比较函数\r1 void* memcmp (void* ptr1, const void* ptr2, size_t num); 返回 0 ptr1 和 ptr2 相同\n返回 \u0026gt; 0 ptr1 大于 ptr2\n返回 \u0026lt; 0 ptr1 小于 ptr2\nmemset() 内存设定函数\r1 void* memset(void* ptr int value, size_t num); 把 ptr 所指向的那块空间的前 num 个字节的内容设定为 value 的值\nmalloc() 内存开辟函数\r1 void* malloc(size_t size); size 单位为字节，不要写 0，这是标准未定义行为 如果找到空间了，返回这块内存空间的指针\n如果没有找到空间，返回 NULL\n因此，使用由 malloc() 开辟的空间前建议先判断空间是否开辟成功\nfree() 返还内存空间函数\r1 free(void* ptr); 将 ptr 所指向的空间返回给操作系统\n请注意:该函数只能释放在堆区上的内存空间\n如果 ptr 为 NULL，该函数将不会执行\n在使用该函数后要将 ptr 置为 NULL\ncalloc() 内存开辟并初始化函数\r1 void* calloc(size_t num, size_t size); num 元素的个数\nsize 每个元素的长度\n同时会将每个元素的值初始化为 0\nrealloc() 内存调整函数\r该函数可以对动态开辟的内存大小进行调整\n1 void* realloc (void*ptr, size_t size); ptr 之前所开辟的内存空间的起始地址\nsize 所要调整的新的大小\n返回值是全新开辟的新的内存地址\n如果需要增加空间，但是原地址后面的空间不够，就会将该内存空间移动至新的位置，同时地址也会被改变。当然，原空间会被释放掉\n有时候看你找不到合适的空间来调整大小，这时就会返回 NULL。因此不建议用调整之前的指针变量来接受 realloc 返回的地址。建议使用临时的指针变量然后进行判断后赋值\n文件操作\r在 C 中，操作系统中的文件有一个文件缓冲系统。在其中最重要的即为文件类型指针，简称文件指针\n每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息 (如文件的名字，文件状态及文件当前的位置等) 这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名为 FILE\n每当打开一个文件的时候，系统会根据文件的情况自动创建一个 FILE 结构的变量，并填充其中的信息 通常，都是通过一个 FILE 的指针来维护这个 FILE 结构的变量，这样使用起来更加方便\n1 FILE* pf; //文件指针变量 定义 pf 是一个指向 FILE 类型数据的指针变量。可以使 pf 指向某个文件的文件信息区 (是一个结构体变量) 通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件\nfopen() 文件打开函数\r1 FILE* fopen(const char* filename, const char* mode); filename 文件名\nmode 打开模式，见下表\n文件打开模式 含义 如果指定的文件不存在 “r” 只读 为了输入数据，打开一个已经存在的文本文件 ERROR “w” 只写 为了输出数据，打开一个文本文件 建立一个新的文件 “a” 追加 向文本尾部追加数据 建立一个新的文件 “rb” 只读 为了输入数据，打开一个二进制文件 ERROR “wb” 只写 为了输出数据，打开一个二进制文件 建立一个新的文件 “ab” 追加 向一个二进制文件尾部追加数据 建立一个新的文件 “r+” 读写 为了读和写，打开一个文本文件 ERROR “w+” 读写 为了读和写，建立一个新的文件 建立一个新的文件 “a+” 读写 打开一个文件，在文件尾部进行读写 建立一个新的文件 “rb+” 读写 为了读和写，打开一个二进制文件 ERROR “wb+” 读写 为了读和写，建立一个新的二进制文件 建立一个新的文件 “ab+” 读写 打开一个二进制文件，在文件尾部进行读写 建立一个新的文件 在使用 w 模式打开一个文件时，会将源文件中已有的数据清空！！！\nfclose() 文件关闭函数\r1 int fclose(FILE* stream); stream 文件指针\n在写完文件后需要使用 fclose() 关闭文件\nfputc() 字符输出函数\r1 void fputc(char ch, FILE* stream); ch 要写入的数据\nstream 文件指针\nfgetc() 字符输入函数\r1 int fgetc(FILE* stream); 从标准输入流中读取信息\n如果该函数读取正常，会返回这个字符的 ACSII 码值，如果读取错误或者文件结束会返回 EOF\n该函数每读一次都会将指针 + 1\nfputs() 文本和输出函数\r1 void fputs(const char str, FILE* stream); str 要写入的字符串\nstream 文件指针\nfgets() 文本行输入函数\r1 char* fgets(char* string, int n, FILE*stream); string 字符指针\nn 读取的字符 (写 100 其实只会读取 99，因为最后一个要填充’\\0’)\nstream 文件指针\nfgets 函数在读取结束的时候，会返回 NULL\n正常读取的时候，返回存放字符串的空间起始地址\nfprintf() 格式化输出函数\r1 int fprintf(FILE* stream, const char* format [, argument]...); stream 文件指针\nformat 格式化转义字符\nargument (可选) 值\nfscanf() 格式化输入函数\r1 int fscanf(FILE* stream, const char* format [, argument]...); stream 文件指针\nformat 格式化转义字符\nargument (可选) 值\nfwrite() 二进制输出函数\r1 size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer 指针指向要被写的数据\nsize 元素的大小 (可以写多个 取决于需求)\ncount 最多写多少个元素\nstream 文件指针\nfread() 二进制输入函数\r1 size_t fread(void* buffer, size_t size, size_t count, FILE* stream); buffer 指针指向要被读的数据\nsize 元素的大小 (可以写多个 取决于需求)\ncount 最多读多少个元素\nstream 文件指针\nfread 函数在读取的时候，返回的是实际读取到的完整元素的个数\n如果发现读取到的完整的元素的个数小于指定的元素个数，这就是最后一次读取了\nsscanf() 字符串格式化读取函数\r1 int sscanf(const char* buffer, const char* format [, argument]...); buffer 要存储的变量\nformat 格式化转义字符\nargument (可选) 值\n从一个字符串中读取一个格式化的数据\nsprintf() 格式化数据转换函数\r1 int sprintf(const char* buffer, const char* format [, argument]...); buffer 要存储的变量\nformat 格式化转义字符\nargument (可选) 值\nfseek() 文件指针定位函数\r1 int fseek(FILE* stream, long int offfset, int origin); stream 文件指针\noffset 偏移量 (负数是往前倒着走)\norigin 位置 (SEEK_CUR 当前文件指针的位置；SEEK_END 文件结尾；SEEK_SET 文件起始位置)\nftell() 文件指针位置返回函数\r1 int ftell(FILE* stream); stream 文件指针 返回文件指针相较于起始位置的偏移量\nrewind() 文件指针返回函数\r1 void rewind(FILE* stream); stream 文件指针 让文件指针回到起始位置\n文件缓冲区\rANSIC 标准采用 “缓冲文件系统 \u0026ldquo;处理的数据文件的，所谓缓冲文件系统是指系统自动地在内中为程序中每一个正在使用的文件开辟一块\u0026rdquo; 文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区 (充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区 (程序变量等)。缓冲区的大小根据 C 编译系统决定的\n程序环境和预处理\r一个 C 程序会通过编译器经过预编译、编译、汇编、链接后才会在运行环境中运行\n预处理\r在预处理阶段，编译器会进行如下步骤\n完成头文件的包含 #include\n#define 定义的符号或宏替换\n删除注释\n编译\r把 C 语言代码转化为汇编代码\n语法分析\n词法分析\n语义分析\n符号汇总\n汇编\r见汇编代码转换为机器指令 (即二进制命令)\n会生成符号表\n链接\r把多个目标文件和链接库进行链接\n合并段表\n符号表的合并和重定位\n运行环境\r程序执行的过程:\n程序必须载入内存中。在有操作系统的环境中:一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成\n程序的执行便开始。接着便调用 main 函数\n开始执行程序代码。这个时候程序将使用一个运行时堆栈 (stack)，存储函数的局部变量和返回地址。程序同时也可以使用静态 (static)内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值\n终止程序。正常终止 main 函数；也有可能是意外终止\n宏和函数\r宏通常被应用于执行简单的运算，比如在两个数中找出较大的一个\n1 #define MAX(a, b) ((a)\u0026gt;(b) ? (a) :(b)) 那为什么不用函数来完成这个任务？\n原因有二:\n用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹。\n更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于 \u0026gt; 来比较的类型。宏是类型无关的。\n当然和宏相比函数也有劣势的地方:\n每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。\n宏是没法调试的。\n宏由于类型无关，也就不够严谨。\n宏可能会带来运算符优先级的问题，导致程容易出现错。宏有时候可以做函数做不到的事情。比如:宏的参数可以出现类型但是函数做不到\n宏有时候可以做函数做不到的事情。比如:宏的参数可以出现类型，但是函数做不到\n宏和函数的一个对比\r属性 #define 函数 代码长度 每次使用时，宏代码都会被插入到程序中。出了非常小的宏之外，程序的长度会大幅度增长 函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码 执行速度 更快 存在函数的调用和返回的额外开销，所以相对会慢一点 操作符优先级 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则临近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号 函数参数只在函数调用的时候求值一次，它的结果传递给函数。表达式的求值结果更容易预测 带有副作用的参数 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果 函数参数只在传参的时候求值一次，结果更容易控制 参数类型 宏的参数于类型无关，只要对参数的操作是合法的，它就可以适用于任何参数类型 函数的参数是与类型有关的，如果参数的类型不通，就需要不同的函数，即使他们执行的任务是不同的 C++:函数模板了解一下不？ 调试 宏是不方便调试的，因为在预处理阶段就会被替换掉 函数是可以逐语句调试的 递归 宏是不能递归的 #define 所定义的宏会在预编译的时候被替换掉\n命名约定\r把宏的名称全部大写，函数名的首字母大写\n#undef 取消定义\r1 #undef M 取消定义一个宏\n条件编译\r我早就忘了\n文件包含\r头文件的包含方式\n#include \u0026lt;stdio.h\u0026gt; 库文件包含，C 语言库中提供的函数头文件使用 \u0026lt;\u0026gt;\n#include \u0026quot;test.h\u0026quot; 本地文件包含，自定义函数的头文件使用 \u0026quot;\u0026quot;\n本质区别是查找策略不同\n\u0026quot;\u0026quot; 会在源文件目录下查找，如果未找到就去库文件中查找\n\u0026lt;\u0026gt; 只会在库文件中查找\n所以你也可以使用 \u0026quot;\u0026quot; 来包含 C 语言库中的头文件 (不推荐\n嵌套文件包含\r1 #pragma once 在第一行添加如上代码，可以避免一个头文件被多次包含\n类型转换\r隐式类型转换\rC的整型算术运算总是至少以缺省整型类型的精度来进行的。\n为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。\n算术操作符转换\r如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。\n优先级 从上到下\nlong double double float unsigned long int long int unsigned int int 整型提升\r表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。\n因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。\n通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。\n常用 C 算法\r请移步至 C语言相关算法\n","date":"2025-01-28T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/123274153_p0.webp","permalink":"https://blog.candquarzy.top/p/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","title":"C语言学习记录"},{"content":"\r死亡？\r即使是现在，虽然说自己已经自杀过一次了… 不过我还是认为死亡应该是人的权力，不应该被限制，如果一个人明明很痛苦了，为什么还要继续活着受罪呢？\n所以我发现，我只是想逃避痛苦罢了…\n抑郁\r一开始，大约是 2022 年 8，9 月份的时候吧，就开始感觉自己的心情不是很正常，会莫名其妙情绪低落。当时我就感觉不太正常。而后的每个月中总有那么几天会莫名其妙情绪低落。并且无论做什么，即使是做自己以前最喜爱的事也觉得毫无乐趣。还记得有一天晚上我和我的朋友小尘 (好哥们，好朋友。以前天天一起打游戏的朋友) 一起玩游戏，可我…… 没有一点开心的感觉，感觉这游戏没有任何意思。那晚，我和他玩的时候几乎没怎么说话，脑子里想的全是负面的，不好的内容，并且我无法控制自己的大脑让它不要想这些东西\n过了几天，我去了省人民医院的心理门诊，挂了一个主任医师的号。去了大夫问了一些问题，其中，我绝对不会忘的是其中有个问题 “你脑中会不会有说话声？” 我当时是想说我自己的想法，会脑子里讲给自己听，类似于自己和自己说话这样，就只是自己的想法而已。很好，喜提精神分裂症\n这个大夫给我的诊断是：精神分裂症妄想型；快速循环型双相情感障碍；焦虑；惊恐障碍。然后开了一堆药，很贵，好像花了快 500 还是 500 多？不过到了现在才知道，这堆药里并没有抗抑郁的……\n回到家后，当我看到有个药物（奥氮平）说明书有一米长，感觉副作用太大了，我就没有吃\n现在知道了，幸亏我没吃，要不然体重奔 300 斤去了 当时我已经 200 斤了应该（\n过了几个月，我去复查，还是看的这个大夫（省人民医院只有这一个心理门诊，并且只有他一位主任医师）。我和他说我脑子里的声音是自己的，大夫说：“正常人脑子里不会有声音”。一句话驳回了我，又听说我没有吃药，所以又开了一堆药，让我回去吃。诊断建议还是 “精神分裂症”\n然后我再也没去看过那个大夫\n买药（亚硝酸钠）\r在那之后的每个月，一般来说是月底，总会有 3-5 天情绪低落。身体也没有力气，什么都不想做，只想躺在那里，脑子里想的全是一些负面的东西……\n2023 年 2 月，我买了一袋亚硝酸钠。说起来也很好笑，这袋亚硝酸钠的价格是 14.4 （4 的谐音死）\n我下单的时候是深夜，那晚应该是失眠了…… 脑子里应该都是不好的想法，不然大概率也不会做这个决定吧\n但到货后并没有直接吃，还是忍住了…… 当时应该还是有点理智的，想死，但没那么强烈。也有可能是还怕死？不太懂……\n亚硝酸钠其实就是工业盐，因此理论上说应该很咸，所以我装成胶囊，保存起来\n后来我发现，亚硝酸钠涨价了。同一个商品链接涨到 20 多一袋。现在不用看了，大约在 23 年 6、7 月份就全部都下架了\n再一次…… 医院\r2023 年 10 月 27 日，通常每次都是月底来抑郁，这次也不例外。因为在学校，于是决定明天让舍友陪着我换一家医院（其实就是省精神病院）去精神科挂号看大夫\n这次我专门询问大夫，我脑子里自己的想法算不算精神分裂症？\n这次的这位大夫说：“每个人脑子里都有自己的意识，自己的想法，这怎么能算精神分裂症呢？”\n然后大夫给我开了 SDS（抑郁自评量表），SAS（焦虑自评量表），SCL-90（症状自评量表）\n如果你觉得你也有抑郁情况，也可以尝试测验，这里我搜罗了一些网站（不保证能用）：\n抑郁自评量表 (SDS) - 在线工具 焦虑自评量表 (SAS) - 在线工具 SCL-90 症状自评量表 做完，拿到结果：\nSDS：82.5（重度抑郁）\nSAS：66.25（中度焦虑）\nSCL-90：332 分 其中 SCL-90 详细得分：\n躯体化 36\n强迫症状 33\n人际关系敏感 34\n抑郁情绪 61\n焦虑情绪 40\n敌对情绪 26\n恐怖情绪 21\n偏执情绪 26\n精神病性 29\n其他 26\n这次大夫给开的药物就两种，丙戊酸钠缓释片，喹硫平片。第一天加起来总共只用吃一片半，大夫人很好，看到我还是学生，因此开的药物也不贵\n而直到后来我才知道，这两种药物里还是没有抗抑郁的……\n自杀\r然后接着是……2023 年的 10 月 29 日，哈！与去精神科看病就仅仅隔了一天。因为那天发生了一些事情，中午就做好了决定，今晚自杀\n啊…… 当然…… 我是有在吃药的… 我现在还记得昨晚吃了半片喹硫平，副作用导致我睡了 11 个小时\n我是那种性格比较倔的人，我家里人也是这样，算是基因遗传吧…… 所以，我做好决定了就没人拉的住我\n当晚 21:50 左右，我接口要上厕所，从宿舍溜了出去，带上了水杯和亚硝酸钠胶囊。坐在操场的椅子上，看着操场上人一个一个离开……\n我选择与我的朋友们打招呼道别，依次给他们发消息，算是最终道别\n其中，小王，我的好朋友，发现我情况不对因此试图劝阻我的自杀行为。但是… 我都已经做好决定了，所以他也没能劝住我\n在服毒 (亚硝酸钠胶囊) 之前已经吃了 2 片艾司唑仑（安眠药）。目的是希望让自己能睡着，在睡梦中死去，可能这样就能够不那么痛苦，因为看到许多人说亚硝酸钠自杀会呕吐啊腹泻啊之类的。我和小王聊着天，22:00 左右，5g 亚硝酸钠，是 10 颗胶囊。一次两颗。没有任何犹豫，真的一点都没有犹豫，我的另一个朋友之前告诉过我的人到临死前会被本能的求生欲占上风。但是我但是并没有这种想法，一口气全吞下去了。当时是杯子里没水了，不然我当时还会继续吞。倒是听说亚硝酸钠 3g 致死，所以吃了 5g，这样肯定也会死就是了\n我把我已经服毒的消息告诉小王，我已经吃了。哈…… 能感觉到他真的很着急，收到我消息的其他人也是，但是…… 我是不可能打 120 走急救的，听说洗胃很痛苦很难受的…\n过了约 5-10 分钟吧，开始腿软了，走不动了。所以找了一个垫子上坐下（体育课用来坐位体前屈的垫子）。顺便观察自己，听说亚硝酸钠会让血液变黑，我就打开手机手电筒观察自己，但是并没有，一切正常\n过了几分钟后… 来了一个人，询问我为什么在这里，我说：“没事，不用管我” 然后走开了。又过了段时间，大约 22:20 左右，又来了一个人来询问我的情况，我依然是说 “没事，不用管我。” 但她没有离开而是继续询问我。也是在这时候，我当着她的面失去了意识……\n急救\r我实在无法想到那么晚了怎么还会有人…… 因此… 不出意外，我被救起来了，不然就没有这篇文章了\n当我醒过来，就在 ICU 里的病床上，一睁眼看到自己鼻子下面塞的呼吸用的管子（不太懂专业的医学术语），两只手被套上塑料手套，左右食指上有夹子一样的东西夹着，应该是监控心率的。当时不管那么多，就感觉非常渴，嘴唇已经干裂的不成样子了。就问护士姐姐要水喝，可能是我刚刚洗过胃吧，就只给喝几毫升。然后我只感觉我脑子很晕，直接又失去意识了，也有可能是睡着了，具体情况就不清楚了\n不知道过了多久，要出院了。嗯…… 当时脑子晕乎乎的，什么也顾不上了，护士姐姐掀起杯子才发现自己全裸，啊…… 就…… 我不知道该说什么了… 还有一个，让我绝对不会忘记的，拔尿管好疼！！！\n出院诊断\n然后出院了\n出院是出院了，但是并没有回家，我是很想回家的，但我的家人不允许，于是把我拉到了精神病院。相当于没出院吧……\n精神病院\r我不知道我怎么过去的了。那会我贫血，没有太多印象。只知道自己很困一直在睡觉，脑子很迷糊不清醒\n后来躺到病房的病床上就开始睡觉…… 也不知道睡了多久来了个大夫，把我叫醒，询问我的情况。他说他是我的主治医师。于是我对他说：“每个月又 3-5 天会情绪低落，有时候会有 1~2 天思维比平时活跃一点”\n大夫：” 双相情感障碍啊，你这还是快速循环 “\n对，就这样，我的病就确定下来了。只靠问你几句话，就直接诊断了你的疾病\n还有个很有意思的，当时我不是贫血嘛，睡着睡着说要抽血，抽了我 6 管血！有点抽象了\n然后还做了腹部彩超… 脑部 CT 一类的检查\n最后大夫说\n都正常，都没问题\n我不知道如何评价了。。。应该说我命硬？不懂了…… 还有因为前几天在抢救的时候洗胃了，就连着饿了好几天。倒是那几天也一直睡觉，脑子晕乎乎的也没感觉到饿\n后来吃上饭了贫血才好些。然后我想想…… 在精神病院干什么呢？不干什么，就是吃药，吃饭，还有睡觉。而且不能出去（后来大夫允许了），病房里也没有插座，可能怕触电自杀吧，窗户上的玻璃也是类似于汽车上的钢化玻璃，试着砸过，根本没反应。不让带筷子，一般病人不让带手机（我特例允许）。所以基本上每天每时每刻都能看到一堆精神病人在楼道里走来走去，就是走过来，再走过去，等着吃饭。大厅里倒是有台电视，乒乓球台，还有下象棋的，也就是这些仅有的娱乐活动\n精神病人是什么样的呢？比如…… 有很抑郁的… 有每天拿一本超级超级厚的书在楼道走的… 有个每天自言自语与政治、新闻有关的话… 有个老头因为花钱多被家里人送进来了，大夫说是躁狂症；最抽象的是还有个说自己是习仲勋的儿子的\n呆久了慢慢发现是真的没有意思啊…… 每天就是睡觉，醒了等吃饭… 无聊的要死。于是我开始询问大夫：“我要住多久才能出院？”\n大夫：”30 天左右差不多 “\n等到快要到 30 天了，我又问大夫：” 我过几天可以出院吗？“\n大夫：” 观察到一个半月吧 “\n多两周…… 也行吧，那就等两周。于是快要到 45 天的时候我又问大夫：“多久能出院？”\n大夫：“住到两个月吧”\n哈！考虑到真的住两个月就 2024 年了，这下我绷不住了。身为大夫一直欺骗病人？所以我发脾气了。真的里面太无聊，第一次感觉到 “浪费时间就是浪费生命” 这句话太正确了\n不过在精神病院里，虽然说你是发脾气了，但是大夫和护士并不会这么认为。他们会认为你精神病发作，说你是躁狂了。遇到这种情况他们一般就让一堆男护士把这个病人摁在地上，然后绑到床上。接着等大夫来，当然大夫来了也没啥用，大夫们只能加药，你病情越控制不住吃的药物越多。住我隔壁的病人吃一次药就是两大把。所以我还挺庆幸的，一天 6 颗药我的抑郁就没有再犯 还得是安非他酮\n回顾\r在后来，我才慢慢了解到我失去意识后发生了什么…… 我算是发现的比较及时，服毒后 1-2 小时送到的急救。但是听说急救的比较晚… 然后就是洗胃和上呼吸机，毕竟呼吸暂停了嘛；还有血液透析之类的……\n我原本以为我心跳停止了，就比较严重嘛…… 因为大夫和我的家人说 “有可能醒不过来，就是醒过来了也可能不能动了（植物人）”。我还以为很严重呢，后来发现心跳并没有停止。感觉好没劲\n出院\r2023 年 12 月 14 日，虽然外面大雪下了有 6-7cm 厚，但是！我绝对不要再呆一周了！为什么要呆一周呢？是这样，你出院肯定要开药带回家吃，药物是每天都要吃的，绝对不能断。结果大夫只有坐诊的时候才能开出处方单子，恰好我的这位主治大夫每周只有星期四上午坐诊。这也就是说，如果我不今天出院，那么就得等下周四才能带上药出院。这绝对不可能，我就是死也要回去\n想起来当时我还发着高烧呢…… 这是咋回事呢？不是说不让出去吗？是这样，有时候可能会让病人下楼活动活动，同时整层楼吃饭用的碗是共享的，吃完饭后就把碗丢回去了，并不用你洗。而他们又不一定洗的干净，所以这是一点，有可能传染。另外，整层楼为了安全和冷，窗户基本上不开，整层楼根本不透气，不互相传染才怪。我临出院的那几天看到包括我发烧的可能有二十多个人\n出院结账的时候发现总共花了 3W，个人自负 1.1W。我上面说过，在医院里，每天除了睡觉就是等吃饭，哦，也就 9 点的时候大夫会来查房。不过这个是概率性的，大夫并不会天天来。所以，这些钱都花到哪了呢？\n这只是一部分，往下滑，根本划不完。仔细看的话每天都是这些所谓的” 治疗 “。可问题是…… 难道把你关在病房里，什么事情也做不了就叫这些治疗吗？我真的不是很懂。这些治疗我统统没有遇到，也不知道是在干嘛。不过嘛…… 这个狗屎地方我绝对不会再进来了\n死亡\r正如我开头所说，我并不怕死，只是怕痛苦。我想，应该没有人不怕痛苦吧？对我来说，死亡代表着逃避责任、摆脱痛苦。我可以不用继续为我自己负责，不用继续痛苦的活在这个世界上了。” 好死不如赖活着 “这句话也许…… 可能只适合那些乐观向上的人吧\n过往与现在\r想想当时被抑郁折磨的我是个什么样子啊…… 就感觉整个人像肾虚了一样，连话都不想说。随身带着刀和亚硝酸钠胶囊…… 害怕自己被人伤害，随时做好自杀的准备…… 哈，我不都不敢说我自己没疯\n而在精神病院只能装一个正常人，如果你情绪低落会被说抑郁，大夫会给你加药；情绪高涨（比如发脾气了）会被当成躁狂，大夫也会给你加药…… 真搞不懂他们到底是如何诊断疾病的。就依我看，你即使没啥病，只要你说的答案不是他们心中的标准答案，那你就是精神病\n在我住院的时候对门有个人被送去 MECT 了，就是我上文中说的那个一次吃药就是两大把的那位。MECT 别看它叫法高级，杨永信应该知道吧？就是那个给孩子头上电击的那个玩意，说可以戒网瘾。其实他做的就是 ECT，不过做 MECT 的话会给你打上麻醉，全麻，因此不会感觉到痛苦。但是听说好像会影响记忆力就是了…… 还好我靠药物控制住了，不然我也得进去（\n现在的我又是什么样呢？手抖，吞咽困难，头晕，呆滞…… 而且大夫告诉我我要终身吃药，因为我是快速循环的双相情感障碍。感觉…… 这难道不是又是一种痛苦的开始吗？\n回到家我发现，自己每天都不知道我在干些什么，一整天脑子都是迷迷糊糊的，比如现在我其实都不知道自己在写什么。偶尔有时候还会有 1S 左右的意识丧失，感觉自己已经被药物搞的不成样子了\n未来呢？吃药，每天吃药，还得终身吃药。。。搞不懂啊… 这不是让我从抑郁的痛苦走出来然后走到每天吃药的痛苦吗？现在每天呆呆的，像活在梦中，成天都没睡醒的感觉…… 这样真的治好我的病了吗？还是把我从一个火坑放入另一个火坑中了？\n好，废话讲完了，感谢你看到这里。其实也没啥，就是自己的一次自杀未遂被救回来的经历，嗯…… 希望每个人都能珍惜生命吧，好好活下去\n去北京看看吧（2024 年 11 月 2 日记）\r2024 年 8 月，和群友聊到这个，就有了这个想法。去北京找更好的大夫看看，说不定能够改药，减药，甚至可以停药。毕竟吃一辈子药物也太不现实了\n而更重要的一点是吃这些药物导致的副作用越来越明显，手抖更加严重，口水分泌过多导致吞咽困难等等…… 和家里人说了要去北京看看家里人也表示支持，最后决定等过完国庆再去北京\n到了北京，北京的大夫也没有什么办法，也是去做量表…… 那当然结果是正常的了。所以大夫看完量表后的结果说我保养的好，让我减药。把抗精神病药减少掉，减少一颗情绪稳定剂，剩下的不变。并且告诉我未来还可以再减，一个月之后再来复查。这确实是一个好消息，我真的很开心，并没有改药而是减药。我本以为这样就可以了\n结果……\n我的抗抑郁药物是安非他酮，这个药和兴奋剂（化学分子式类似于安非他命）很像，可以让精神一直保持亢奋，因此会导致睡不着觉。于是我当晚就失眠，快到凌晨 2 点才睡着。因为第二天我打算去玩，于是我那天就睡了不到 5 个小时。第二天起来，我想说会不会是因为这个药物是中午吃的，所以导致它到了晚上药效还在？于是我按照说明书不按那个大夫说的我改成早上吃。当然，今天一整天我都算是很有精神，虽然我脑子晕乎乎的。到了晚上，还是睡不着，依然是只睡了 5 个小时不到，然后第二天就要回家了，没办法，我只能在早上起来继续吃 2 片安非他酮，感觉就像吸毒一样。靠吃药来维持自己的精神状态\n于是回来之后我决定，自行减药，减少一颗安非他酮（抗抑郁药），这样才能够睡着\n结束了？（2025 年 4 月 5 日记）\r那个大夫之前说的是一个月复查一次，但是我迫于经济能力没有办法一个月去一次北京。北京的这家安定医院在北京二环边，住宿费就很贵，还有路费，饭费等等…… 因此决定 3 月底去一次北京\n由于之前我挂的那个大夫已经不在这家医院坐诊了，因此我挂了另一个大夫的号\n到了当天，见到大夫。大夫说：你可以把安非他酮停了，但是碳酸锂还是加到刚出院时候那样吧。因为你是躁狂，碳酸锂这个药物可以控制躁狂和抑郁 然后我问大夫，要不要做什么检查或量表？大夫说… 不用做量表，经常查一下甲功和肝功就行（碳酸锂对肝脏不好）。然后问我今天早上吃饭没？我说吃了，我回去做吧，回去我还有医保。大夫说那也可以\n我最后问了一句，那我什么时候可以停药，再来复查？大夫说先让我吃着没有给我肯定的答案…\n好叭…… 这次看病算是白来了\n不过和朋友贴贴的很开心！\n","date":"2024-09-14T00:00:00Z","image":"https://raw.githubusercontent.com/Candquarzy/PicGO_For_Candy/refs/heads/master/blog/2024-11-11_22.58.03_fix.webp","permalink":"https://blog.candquarzy.top/p/%E6%8A%91%E9%83%81-%E8%87%AA%E6%9D%80-%E6%AD%BB%E4%BA%A1-%E9%87%8D%E7%94%9F/","title":"抑郁 - 自杀 - 死亡? - 重生？"}]